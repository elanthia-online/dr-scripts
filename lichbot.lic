# want_script_output
=begin
  Documentation: https://elanthipedia.play.net/Lich_script_repository#lichbot
=end

custom_require.call(%w(common common-arcana common-items drinfomon events))

class CharacterValidator
  def initialize(announce, sleep, greet)
    waitrt?
    fput('sleep') if sleep

    @lnet = (Script.running + Script.hidden).find { |val| val.name == 'lnet' }
    @validated_characters = []
    @greet = greet

    @lnet.unique_buffer.push("chat Lichbot is up and running in room #{Room.current.id}! Whisper me 'help' for more details.") if announce
  end

  def validate(character)
    return if valid?(character)

    echo "Attempting to validate: #{character}"
    @lnet.unique_buffer.push("who #{character}")
  end

  def confirm(character)
    return if valid?(character)

    echo "Successfully validated: #{character}"
    @validated_characters << character

    return unless @greet

    put "whisper #{character} Hi! I'm your friendly neighborhood lichbot. Whisper me 'help' for more details. Don't worry, I've memorized your name so you won't see this message again."
  end

  def valid?(character)
    @validated_characters.include?(character)
  end
end

class Lichbot
  include DRC
  include DRCA
  include DRCI

  def initialize
    Flags.add('give-accepted', '.* has accepted your offer and is now holding .*')
    Flags.add('give-declined', '.* has declined the offer')
    Flags.add('give-expired', 'Your offer to .* has expired')

    Flags.add('stopped-listening', 'Your teacher is not here, so you are no longer learning anything', '.* stops teaching')

    @settings = get_settings
    @last_action = Time.now
    @last_teacher = nil
    @inventory = []
    @bot_bank = UserVars.bot_bank || {}
    refresh_inventory
  end

  def accept(character)
    @last_action = Time.now
    waitrt?
    bput('accept', 'You accept')
    stow_hands
    if right_hand || left_hand
      fput("drop my #{right_hand}") if right_hand
      fput("drop my #{left_hand}") if left_hand
      fput "whisper #{character} ***ERROR*** I was unable to stow that item, so I have dropped it. If you cannot pick it up, try again in 30 seconds."
    else
      refresh_inventory
    end
  end

  def list_buffs(character)
    @last_action = Time.now
    fput "whisper #{character} My buffs are:"
    @settings.lichbot_buffs.each { |buff| fput "whisper #{character}   #{buff['name']} [#{buff['abbrev']}] - #{buff['description']}" }
    fput "whisper #{character} END"
  end

  def cast_buff(character, abbrev)
    @last_action = Time.now
    buff_data = @settings.lichbot_buffs.find { |buff| buff['abbrev'] == abbrev }
    unless buff_data
      fput "whisper #{character} I'm sorry, I do not know spell [#{abbrev}]"
      return
    end

    fput "whisper #{character} Preparing [#{buff_data['name']}] now"
    buff_data['cast'] = "cast #{character}"
    buff(buff_data, @settings)
    fput "whisper #{character} Buffing complete"
  end

  def give(character, item)
    @last_action = Time.now
    unless get_item?(item)
      fput "whisper #{character} Sorry, I failed to find [#{item}] in my inventory"
      return
    end

    Flags.reset('give-accepted')
    Flags.reset('give-expired')
    Flags.reset('give-declined')
    case bput("give #{item} to #{character}", 'You offer', 'What is it')
    when 'What is it'
      fput "whisper #{character} Sorry, I failed to give you [#{item}]"
      stow_hands
      return
    end

    pause 0.5 until Flags['give-accepted'] || Flags['give-expired'] || Flags['give-declined']

    bput("stow #{item}", 'You put') if Flags['give-expired'] || Flags['give-declined']
    refresh_inventory if Flags['give-accepted']
  end

  def inventory(character)
    @last_action = Time.now
    fput "whisper #{character} My inventory is:"
    @inventory.each { |item| fput "whisper #{character}   #{item}" }
    fput "whisper #{character} END"
  end

  def help(character)
    @last_action = Time.now
    fput "whisper #{character} Supported commands are:"
    fput "whisper #{character}   (help) - this list"
    fput "whisper #{character}   (inv|inventory) - view the items I have available"
    fput "whisper #{character}   (bal|balance) - view your current bot balance"
    fput "whisper #{character}   (with|withdraw) [amount] - withdraw [amount] from your bot balance."
    fput "whisper #{character}   (give|giveme) [item] - take an item from me"
    fput "whisper #{character}   (buffs|spells) - view the buffs I can cast"
    fput "whisper #{character}   (buff|cast) [abbreviation] - receive [abbreviation] buff from me"
    fput "whisper #{character} I will also accept and stow any item you trade me, or accept coins via TIPs to hold for you."
  end

  def balance(character)
    @last_action = Time.now
    unless has_bot_account(character)
      fput "whisper #{character} Apologies, but my record shows that you do not have a Bot Bank account."
      pause 0.5
      fput "whisper #{character} You can tip me in Kronars to start one."
      return
    end

    fput "whisper #{character} Your current balance is: #{@bot_bank[character]} Kronar."
  end

  def deposit(character, amount, denomination)
    # TODO: Handle when multiple withdraw/deposit requests are being made (queue?)
    # TODO: Handle case when player tries to give coins directly to bot (without using TIP). OR, if they
    #       do not use the TIP command, check against current copper in-hand to ensure you actually received the
    #       amount given, to avoid spoofing a 'give'
    @last_action = Time.now
    if denomination =~ /(Lirum|Dokora)/i
      fput "whisper #{character} Unfortunately, I'm only accepting Kronars at the moment."
      bput("decline tip", 'You decline .* offer', 'But you have no tip offers outstanding.')
      return
    end
    
    has_account = has_bot_account(character)

    case bput("accept tip", "You accept #{character}'s tip and slip it away", "#{character}'s tip offer has expired.")
    when /.*\'s tip offer has expired./i
      fput "whisper #{character} Sorry! I was busy and could not accept your deposit in time. Try again."
    when /You accept .*'s tip and slip it away/i
      msg = has_account ? "Thank you for your business! Your new balance is: " : "You've officially started a new Bot Account. Your balance is: "

      @bot_bank[character] = has_account ? (get_balance(character) + amount.to_i) : amount.to_i
      fput "whisper #{character} #{msg} #{@bot_bank[character]} Kronar!"
    end

    # Save the bot bank to UserVars
    UserVars.bot_bank = @bot_bank
  end

  def withdraw(character, amount)
    # TODO: Handle when multiple withdraw/deposit requests are being made (queue?)
    @last_action = Time.now
    unless has_bot_account(character)
      fput "whisper #{character} Apologies, but my record shows that you do not have a Bot Bank account."
      pause 0.5
      fput "whisper #{character} You can tip me in Kronars to start one."
      return
    end

    balance = get_balance(character)
    if balance < amount.to_i
      fput "whisper #{character} The max you can withdraw is: #{balance} Kronar."
      return
    end

    case bput("tip #{character} #{amount} kronar", '\w+ declines your tip offer.', 'Your tip offer to \w+ has expired.', '\w+ accepts your tip and slips it away with a smile')
    when /\w+ declines your tip offer./i
    when /Your tip offer to \w+ has expired./i
      fput "whisper #{character} Alright then, I will continue to hold on to it."
    when /\w+ accepts your tip and slips it away with a smile/i
      balance = balance - amount.to_i
      if balance <= 0
        fput "whisper #{character} Your account has now been closed!"
        @bot_bank.delete(character)
      else
        fput "whisper #{character} You now have a remaining balance of: #{balance} Kronar."
        @bot_bank[character] = balance
      end
    end

    # Save the bot bank to UserVars
    UserVars.bot_bank = @bot_bank
  end

  def ping
    return if @last_action + 60 * 3 > Time.now
    @last_action = Time.now

    if Flags['stopped-listening'] || @last_teacher.nil? || !listen?(@last_teacher)
      classes = assess_teach
      @last_teacher = classes
                      .reject { |t, s| t.nil? || s.nil? }
                      .sort_by { |_t, s| [DRSkill.getxp(s), DRSkill.getrank(s)] }
                      .find { |t, _s| listen?(t) }
                      .first
      Flags.reset('stopped-listening')
    end

    if should_train?('Attunement')
      bput('perc', 'You reach out')
      waitrt?
    end

    if should_train?('Augmentation') || should_train?('Arcana')
      buff_data = @settings
                  .lichbot_buffs
                  .sort_by { |spell| DRSpells.active_spells[spell['name']] || 0 }
                  .first
      buff(buff_data, @settings) if buff_data
    end
  end

  private

  def should_train?(skill)
    DRSkill.getxp(skill) < 28
  end

  def get_item?(item)
    waitrt?

    case bput("get #{item}", 'You get', 'You are already holding', 'But that is already in your inventory', 'Please rephrase', 'What were you', 'You should stop playing')
    when 'But that is already in your inventory'
      return get_item?("second #{item}")
    when 'You should stop playing'
      bput('stop play', 'You stop playing your song', 'In the name of', 'But you\'re not performing')
      return get_item?(item)
    when 'Please rephrase', 'What were you'
      return false
    end

    true
  end

  def get_balance(character)
    unless has_bot_account(character)
      return 0
    else
      return @bot_bank[character].to_i
    end
  end

  def has_bot_account(character)
    unless @bot_bank.has_key?(character)
      return false
    else
      return true
    end
  end

  def refresh_inventory
    waitrt?
    fput('inv list')
    pause

    log = reget(200)
    start_index = log.rindex { |x| x =~ /You have/i } + 1
    end_index = log.rindex { |x| x =~ /Roundtime/i } - 1

    @inventory =
      log[start_index..end_index]
      .select { |item| item.lstrip.start_with?('-') }
      .map { |item| item.strip[1..-1] }
  end
end

arg_definitions = [
  [
    { name: 'start', regex: /start/i, description: 'Required: prevents accidentally starting up lichbot' },
    { name: 'announce', regex: /announce/i, optional: true, description: 'If arg is present, lichbot will announce its presence in LNet' },
    { name: 'sleep', regex: /sleep/i, optional: true, description: 'If arg is present, lichbot will sleep so as not to gain experience' },
    { name: 'greet', regex: /greet/i, optional: true, description: 'If arg is present, lichbot will greet characters after validating (but only once)' }
  ]
]

args = parse_args(arg_definitions)

lichbot = Lichbot.new
validator = CharacterValidator.new(args.announce, args.sleep, args.greet)

@last_room_list = []
loop do
  line = script.gets?
  pause 0.05 unless line

  if DRRoom.pcs != @last_room_list
    (DRRoom.pcs - @last_room_list).each { |name| validator.validate(name) }
    @last_room_list = DRRoom.pcs
  end

  case line
  when /^(.*) offers you (.*).  Enter ACCEPT to accept the offer or DECLINE to decline it.  The offer will expire in 30 seconds.$/
    character = Regexp.last_match(1)

    lichbot.accept(character) if validator.valid?(character)
  when /^(.*) whispers, "(inv|inventory)"$/i
    character = Regexp.last_match(1)

    lichbot.inventory(character) if validator.valid?(character)
  when /^(.*) whispers, "(help)"$/i
    character = Regexp.last_match(1)

    lichbot.help(character) if validator.valid?(character)
  when /^(.*) offers you a tip of (\d+) (\w+).  Type ACCEPT TIP, to accept it or DECLINE TIP to refuse it.$/
    character = Regexp.last_match(1)
    amount = Regexp.last_match(2)
    denomination = Regexp.last_match(3)

    lichbot.deposit(character, amount, denomination) if validator.valid?(character)
  when /^(.*) whispers, "(with|withdraw) (\d+)\s*(Kro.*|Lir.*|Dok.*)*"$/i
    character = Regexp.last_match(1)
    amount = Regexp.last_match(3)

    lichbot.withdraw(character, amount) if validator.valid?(character)
  when /^(.*) whispers, "(bal|balance)"$/i
    character = Regexp.last_match(1)

    lichbot.balance(character) if validator.valid?(character)
  when /^(.*) whispers, "(buffs|spells)"$/i
    character = Regexp.last_match(1)

    lichbot.list_buffs(character) if validator.valid?(character)
  when /^(.*) whispers, "(give|giveme) (.*)"$/i
    character = Regexp.last_match(1)
    item = Regexp.last_match(3)

    lichbot.give(character, item) if validator.valid?(character)
  when /^(.*) whispers, "(buff|cast) (.*)"$/i
    character = Regexp.last_match(1)
    abbrev = Regexp.last_match(3)

    lichbot.cast_buff(character, abbrev) if validator.valid?(character)
  when /^(.*) whispers, ".*"$/i
    character = Regexp.last_match(1)

    fput "whisper #{character} I'm sorry, I did not understand that command"
    lichbot.help(character)
  when /^\[server\]: "DR:(.*) is tuned to the following channels.*"$/
    character = Regexp.last_match(1)

    validator.confirm(character)
  when /^\[server\]: "DR:(.*) is connected but not tuned to any channels.*"$/
    character = Regexp.last_match(1)

    validator.confirm(character)
  else
    lichbot.ping
  end
end
