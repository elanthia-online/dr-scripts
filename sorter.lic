=begin
  Documentation: https://elanthipedia.play.net/Lich_script_development#sorter
=end

custom_require.call(%w[common common-items])
require 'terminal-table'

class Sorter
  def initialize(use_table)
    @settings = get_settings
    @settings.sorter['ignore_categories'] ||= 'nil'
    @use_table = use_table
    setup_downstream_hook
  end

  def setup_downstream_hook
    action = proc { |line| process_line(line) }
    DownstreamHook.add('sorter', action)
  end

  def process_line(line)
    if line =~ /^(You rummage .*? and see .*?|You rummage .*? but there is nothing in there\.)/
      container_name, items = parse_rummage_output(line)
      sorted_items = sort_items(items)
      @use_table ? display_table(sorted_items, container_name) : display_default(sorted_items, container_name)
      nil # Suppress the original line output
    elsif line =~ /^(?:In|On) the (.*?) you see (.*)\./
      container_name = Regexp.last_match(1).strip
      contents = Regexp.last_match(2)
      items = DRC.list_to_array(contents)
      sorted_items = sort_items(items)
      @use_table ? display_table(sorted_items, container_name) : display_default(sorted_items, container_name)
      nil # Suppress the original line output
    elsif line =~ /^Spread out on the (.*?) you see (.*)\./
      container_name = "on the #{Regexp.last_match(1).strip}"
      contents = Regexp.last_match(2)
      items = DRC.list_to_array(contents)
      sorted_items = sort_items(items)
      @use_table ? display_table(sorted_items, container_name) : display_default(sorted_items, container_name)
      nil # Suppress the original line output
    else
      line # Allow non-matching lines to pass through
    end
  end

  def parse_rummage_output(line)
    if line =~ /but there is nothing in there/
      container_name = line.match(/^You rummage through (.*?) but/)[1].strip
      return [container_name, []]
    else
      container_name = line.match(/^You rummage (?:in|on) (.*?) and see/)[1].strip
      contents = line.sub(/^You rummage .*? and see /, '').chomp('.')
      return [container_name, DRC.list_to_array(contents)]
    end
  end

  def sort_items(items)
    sorted = {}
    items.each do |item|
      clean_item = item.sub(/^\s*?\b(?:a|an|some|and|the)\b\s/, '').chomp('.').strip
      noun = DRC.get_noun(clean_item)
      type = get_item_type(clean_item, noun)

      if sorted[type]
        if sorted[type][clean_item]
          sorted[type][clean_item][:qty] += 1
        else
          sorted[type][clean_item] = { noun: noun, qty: 1, full_description: item.chomp('.').strip }
        end
      else
        sorted[type] = { clean_item => { noun: noun, qty: 1, full_description: item.chomp('.').strip } }
      end
    end
    sorted
  end

  def get_item_type(item, noun)
    item_data = get_data('sorting').to_h.merge(get_data('items').to_h)
    category = 'Other'

    item_data.each do |key, value|
      if noun =~ /#{value.join('$|').concat('$')}/i || item =~ /(?:#{value.join('$|').concat('$')})/i
        category = key.to_s.sub(/_nouns|_types/, '').capitalize
        break
      end
    end

    category
  end

  def display_table(sorted_items, container_name)
    table = Terminal::Table.new do |t|
      t.title = "Contents of #{container_name.strip}"
      t.style = { border_x: "-", border_i: "+", border_y: "|" }

      if sorted_items.empty?
        t << [{ value: "This container is empty", alignment: :center, colspan: 2 }]
      else
        t.headings = ['Item', 'Qty.']
        sorted_types = sorted_items.keys.sort_by { |type| type == "Other" ? [1, type] : [0, type] }

        sorted_types.each do |type|
          items = sorted_items[type]
          t << :separator
          t << [{ value: type.strip, alignment: :center, colspan: 2 }]
          t << :separator
          items.each do |item, data|
            t << [data[:full_description].strip, data[:qty]]
          end
        end
      end
    end

    table_string = table.to_s.gsub('[[MONSTERBOLD]]', monsterbold_start).gsub('[[/MONSTERBOLD]]', monsterbold_end)
    Lich::Messaging.mono(table_string)
  end

  def display_default(sorted_items, container_name)
    output = "#{container_name}:\n"
    sorted_items.sort.each do |category_name, category_contents|
      count = category_contents.values.sum { |item| item[:qty] }
      output << "#{monsterbold_start}#{category_name} (#{count}):#{monsterbold_end} "
      category_contents.each do |item, data|
        output << if data[:qty] > 1
                    "#{data[:full_description]} (#{data[:qty]}), "
                  else
                    "#{data[:full_description]}, "
                  end
      end
      output.chomp!(', ')
      output << ".\n"
    end
    Lich::Messaging.mono(output)
  end

  def cleanup_hook
    DownstreamHook.remove('sorter')
  end

end

use_table = script.vars.include?('table')
sorter_instance = Sorter.new(use_table)

begin
  # Keep the script running in the background to monitor incoming lines.
  while true; sleep(0.1); end
  
ensure
  sorter_instance.cleanup_hook # Clean up when the script exits.
end
