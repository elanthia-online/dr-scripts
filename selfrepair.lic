custom_require.call(%w[common common-crafting common-items equipmanager])

class SelfRepair
  def initialize
    arg_definitions = [[]]
    args = parse_args(arg_definitions, true)
    @settings = get_settings
    @bag = @settings.crafting_container
    @bag_items = @settings.crafting_items_in_container
    @equipmanager = EquipmentManager.new
    town = args.flex.find { |element| element =~ $HOMETOWN_REGEX } || @settings.hometown
    gear_list = (build_list(args.flex) - [town]).flatten
    @craft_data = get_data('crafting')['blacksmithing'][town.capitalize]
    DRCC.check_consumables('oil', @craft_data['finisher-room'], @craft_data['finisher-number'], @bag, @bag_items, nil, gear_list.size)
    DRCC.check_consumables('wire brush', @craft_data['finisher-room'], 10, @bag, @bag_items, nil, gear_list.size)

    gear_list.each do |gear_item|
      unless smart_get_gear(gear_item)
        DRC.message("Missing #{gear_item}, skipping")
        DRC.beep
        next
      end
      repair_item(gear_item)
      break unless smart_stow_gear(gear_item)
    end
  end

  def build_list(selections)
    gear_list = []
    ['forging', 'tinkering', 'carving', 'shaping', 'outfitting', 'alchemy', 'enchanting'].each do |toolset|
        if selections.include?(toolset)
            gear_list << @settings.send(toolset + '_tools') # grabbing a list of tools from that set and adding them to gear
            selections -= [toolset] # removing the toolset name from tools to be repaired
        end
    end
    gear_list + selections
  end

  def repair_item(item)
    repair_tool = ['wire brush', 'oil']
    repair_tool.each do |tool| #iterates once for each: wire brush, oil
      DRCI.get_item(tool, @bag)
      command = tool == 'wire brush' ? "rub my #{item} with my wire brush" : "pour my oil on my #{item}" #changes the command based on the tool, instead of a second case statement, since it's just one of each
      case DRC.bput(command, 'Roundtime', 'not damaged enough',
                    'You cannot do that while engaged!', 
                    'cannot figure out how', 'Pour what')
      when 'Roundtime' #successful partial repair (one brush or one oil)
        DRCI.put_away_item?(tool, @bag)
        next #move to oil, or move out of loop
      when 'not damaged enough' #doesn't require repair, leaving loop for the next tool
        DRCI.put_away_item?(tool, @bag)
        break #leave brush/oil loop and choose next tool
      when 'Pour what'
        DRCC.check_consumables('oil', info['finisher-room'], info['finisher-number'], @bag, @bag_items, nil) #somehow ran out of oil, fetching more
        DRCI.get_item(tool, @bag)
        DRC.bput("pour my oil on my #{item}", 'Roundtime')
        DRCI.put_away_item?(tool, @bag)
        next #oil done, next tool
      when 'You cannot do that while engaged!'
        DRC.message("Cannot repair in combat")
        smart_stow_gear(item)
        DRCI.put_away_item?(tool, @bag)
        exit
      when 'cannot figure out how'
        DRC.message("Something has gone wrong, exiting repair")
        DRCI.put_away_item?(tool, @bag)
        return
      end
    end
  end

  def smart_get_gear(item)
    return false unless item

    if (toolbelt = [@settings.forging_belt, @settings.engineering_belt, @settings.outfitting_belt, @settings.alchemy_belt, @settings.enchanting_belt].select { |belt| belt["items"].find { |name| name =~ /\b#{item}\b/i } }.first)
      DRCC.get_crafting_item(item, @bag, @bag_items, toolbelt)
    elsif [@settings.forging_tools, @settings.tinkering_tools, @settings.carving_tools, @settings.shaping_tools, @settings.outfitting_tools, @settings.alchemy_tools, @settings.enchanting_tools].any? { |tools| tools.any? { |name| name =~ /\b#{item}\b/i } }
      DRCI.get_item?(item, @bag)
    elsif (gear_item = @equipmanager.items.find { |gear| gear.name =~ /#{item}/ })      
      @equipmanager.get_item?(gear_item)
    else
      DRCI.get_item?(item)
    end
  end

  def smart_stow_gear(item)
    return true unless item

    if (toolbelt = [@settings.forging_belt, @settings.engineering_belt, @settings.outfitting_belt, @settings.alchemy_belt, @settings.enchanting_belt].select { |belt| belt["items"].find { |name| name =~ /\b#{item}\b/i } }.first)
      DRCC.stow_crafting_item(item, @bag, toolbelt) # hopefully stows the tool appropriately.
    elsif [@settings.forging_tools, @settings.tinkering_tools, @settings.carving_tools, @settings.shaping_tools, @settings.outfitting_tools, @settings.alchemy_tools, @settings.enchanting_tools].any? { |tools| tools.any? { |name| name =~ /\b#{item}\b/i } }
      DRCI.put_away_item?(item, @bag)
    else
      @equipmanager.return_held_gear
    end
  end
end

SelfRepair.new
