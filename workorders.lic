=begin
  All in one training and workorder script for crafting
=end

custom_require.call(%w[common common-crafting common-items common-money common-travel events])

class WOData
  attr_accessor :career_thresholds, :hard_thresholds, :challenging_thresholds, :easy_thresholds, :tailoring, :leatherworking, :blacksmithing, :weaponsmithing, :armorsmithing, :remedies, :artificing, :bone_carving, :stone_carving, :shaping, :tinkering, :rank_map

  def initialize
    ## A sliding scale, representing a delayed move up the difficutly ladder depending on your workorder_diff setting. Default is challenging.
    @career_thresholds      = [0, 25, 50, 75, 125, 175, 275, 400, 500, 600, 1000, 1500]
    @hard_thresholds        = [25, 50, 75, 125, 175, 275, 400, 500, 600, 1000, 1500, 1750]
    @challenging_thresholds = [50, 75, 125, 175, 275, 400, 500, 600, 1000, 1500, 1750, 1750]
    @easy_thresholds        = [75, 125, 175, 275, 400, 500, 600, 1000, 1500, 1750, 1750, 1750]

    @tailoring      = ['some knitted socks', 'some knitted mittens', 'a knitted hat', 'some knitted gloves', 'some knitted hose', 'a knitted cloak', 'a cloth haversack', 'a deeply-hooded cloak', 'some flowing cloth robes', 'a cloth mining belt', 'a cloth survival belt', 'a cloth artisan\'s belt']
    @leatherworking = ['a leather armband', 'a leather headband', 'a leather hat', 'a leather dress belt', 'a leather tunic', 'a leather utility belt', 'a medium leather shield', 'a leather kite shield', 'a leather hunting shirt', 'a leather mining belt', 'a leather war belt', 'a leather artisan\'s belt']
    @blacksmithing  = ['a shallow metal cup', 'a short metal mug', 'a back scratcher', 'a small metal flask', 'a metal lockpick ring', 'a metal armband', 'some metal clippers', 'a triangular wire sieve', 'a serrated hide scraper', 'a metal mask', 'some thin sewing needles', 'a trapezoidal wire sieve']
    @weaponsmithing = ['a metal dagger', 'a metal short sword', 'a metal falcata', 'a metal rapier', 'a metal boomerang', 'a metal throwing spike', 'some metal knuckles', 'some metal elbow spikes', 'some spiked metal knuckles', 'some metal hand claws', 'a thin-bladed metal fan', 'a metal riste']
    @armorsmithing  = ['a metal ring aventail', 'a metal chain mask', 'a metal mail mask', 'some metal mail gloves', 'a metal chain tasset', 'a metal mail tasset', 'a simple metal parry stick', 'a metal valnik shield', 'a metal aegis', 'a metal war shield', 'a laminar hauberk', 'some heavy fluted plate']
    @remedies       = ['some blister cream', 'some moisturizing ointment', 'some chest salve', 'a neck potion', 'some limb salve', 'some chest ungent', 'some neck tonic', 'some eye tonic', 'a body elixir', 'a general elixir', 'some refreshment elixir', 'some vigor poultices']
    @artificing     = ['a radiant trinket', 'a mana trinket', 'a wind trinket', 'an earth trinket', 'a fire trinket', 'a water trinket', 'simple gwethsmasher', 'a destructive focus', 'a fire focus', 'a frost focus', 'an electric focus', 'an electric focus']
    @bone_carving   = ['a bone toe ring', 'a bone pin', 'a shallow bone cup', 'a bone medallion', 'a bone brooch', 'a bone armband', 'a bone tiara', 'an articulated bone necklace', 'a bone crown', 'a bone comb', 'a bone haircomb', 'an ornate bone burin']
    @stone_carving  = ['a small stone block', 'a thin stone slab', 'a short stone pole', 'a shallow stone basin', 'a small stone sphere', 'a stone armband', 'a stone choker', 'a stone circlet', 'a stone crown', 'a stone mask', 'an ornate runestone', 'an ornate runestone']
    @shaping        = ['a wood band', 'a wood bracelet', 'a wood cloak pin', 'a wood amulet', 'a wood brooch', 'a wood armband', 'a wood choker', 'an articulated wood necklace', 'a wood crown', 'a wood comb', 'a wood haircomb', 'a detailed wood statue']
    @tinkering      = ['a toy crossbow', 'a simple crossbow', 'a small music box', 'a light crossbow', 'a flight crossbow', 'a miniature male soldier', 'a musical box', 'a telescope', 'a competition crossbow', 'a competition arbalest', 'a wood haircomb', 'a clockwork telescope']

    @rank_map = { 'tailoring'      => 'Outfitting',
                  'leatherworking' => 'Outfitting',
                  'blacksmithing'  => 'Forging',
                  'weaponsmithing' => 'Forging',
                  'armorsmithing'  => 'Forging',
                  'remedies'       => 'Alchemy',
                  'artificing'     => 'Enchanting',
                  'bone_carving'   => 'Engineering',
                  'stone_carving'  => 'Engineering',
                  'shaping'        => 'Engineering',
                  'tinkering'      => 'Engineering' }
  end
end

class WorkOrder
  def initialize
    arg_definitions = [
      [
        { name: 'discipline', options: %w[tailoring leatherworking blacksmithing weaponsmithing armorsmithing remedies artificing carving shaping tinkering], description: 'What type of workorder to do?' },
        { name: 'train', regex: /train/i, optional: true, description: 'train a particular craft to high mindstate instead of doing a workorder for prestige' },
        { name: 'debug', regex: /debug/i, optional: true, description: 'Displays debug information' }
      ]
    ]

    args                            = parse_args(arg_definitions)
    @debug                          = args.debug
    @settings                       = get_settings
    @ordinals                       = $ORDINALS
    @crafting_data                  = get_data('crafting')
    @recipe_parts                   = @crafting_data['recipe_parts']
    @bag                            = @settings.crafting_container
    @bag_items                      = @settings.crafting_items_in_container
    @hometown                       = @settings.crafting_hometown[args.discipline] || @settings.crafting_hometown || @settings.hometown
    @deeds_room                     = @craft_data.deeds[@hometown]['room']
    @deeds_number                   = @craft_data.deeds[@hometown]['medium_number']
    @carving_type                   = @settings.carving_workorder_material_type
    @min_items                      = @settings.workorder_min_items
    @max_items                      = @settings.workorder_max_items
    @recipe_overrides               = @settings.workorder_recipes || {}
    @cash_on_hand                   = @settings.workorder_cash_on_hand
    @craft_max_mindstate            = @settings.craft_max_mindstate
    @retain_crafting_materials      = @settings.retain_crafting_materials
    @workorders_repair              = @settings.workorders_repair
    @workorders_override_store      = @settings.workorders_override_store
    @workorders_repair_own_tools    = @settings.workorders_repair_own_tools
    @workorders_materials           = @settings.workorders_materials
    @workorders_deed_storage        = @settings.workorders_deed_storage || @bag
    @workorders_collect_herbs       = @settings.workorders_collect_herbs
    Flags.add('proper-repair', 'Your excellent training in the ways of tool repair')

    DRC.wait_for_script_to_complete('safe-room', ['force']) if @settings.workorders_force_heal

    args.train ? train_craft(args.discipline) : work_order(args.discipline)
  end

  def train_craft(discipline)
    @skip_logging = true
    wod_disc = discipline # copying this variable for later modification
    info = if discipline =~ /weaponsmithing|armorsmithing/i
             @crafting_data['blacksmithing'][@hometown]
           elsif discipline == 'leatherworking'
             @crafting_data['tailoring'][@hometown]
           elsif discipline == 'tinkering'
             @crafting_data['shaping'][@hometown]
           else
             @crafting_data[discipline][@hometown]
           end

    if discipline == 'carving'
      wod_disc = [@carving_type, discipline].join('_')
      echo "wod_disc set as #{wod_disc} for the purposes of carving recipes" + debug_line if @debug
    elsif discipline == 'leatherworking'
      discipline = 'tailoring'
    end

    case @settings.workorder_diff[wod_disc]
    when nil
      case @settings.workorder_diff
      when nil
        echo "Setting difficulty to Challenging" + debug_line if @debug
      when 'easy', 'challenging', 'hard', 'career'
        echo "Difficulty set at: #{@settings.workorder_diff}" + debug_line if @debug
      else
        DRC.message("Invalid difficulty: #{@settings.workorder_diff}. Options include easy, challenging, hard, or career. Defaulting to Challenging")
        @settings.workorder_diff = 'challenging'
      end
    when 'easy', 'challenging', 'hard', 'career'
      echo "Difficulty set at: #{@settings.workorder_diff[wod_disc]}" + debug_line if @debug
    else
      DRC.message("Invalid difficulty: #{@settings.workorder_diff[wod_disc]}. Options include easy, challenging, hard, or career. Defaulting to Challenging")
      @settings.workorder_diff[wod_disc] = 'challenging'
    end

    if @recipe_overrides[wod_disc].size == 12
      recipe_array = @recipe_overrides[wod_disc]
    else
      echo("Custom recipe list for #{wod_disc} size: #{@recipe_overrides[wod_disc].size}") + debug_line if @debug
      DRC.message("You have a list of custom recipes, but number of recipes must be 12 (one for each tier of difficulty) to use custom recipe selections for training. Defaulting to master list.")
      recipe_array = WOD.send wod_disc
    end

    if @settings.workorder_diff.is_a?(Hash) && @settings.workorder_diff[wod_disc]
      echo "Difficulty is a Hash, using your difficulty setting for #{wod_disc}: #{@settings.workorder_diff[wod_disc]}" + debug_line if @debug
      recipe_selections = WOD.send(@settings.workorder_diff[wod_disc] + '_thresholds').zip(recipe_array) # gets our filled hash
    elsif @settings.workorder_diff.is_a?(String)
      echo "Difficulty is a String, using your difficulty setting: #{@settings.workorder_diff}" + debug_line if @debug
      recipe_selections = WOD.send(@settings.workorder_diff + '_thresholds').zip(recipe_array)
    else
      recipe_selections = WOD.challenging_thresholds.zip(recipe_array)
    end
    echo recipe_selections if @debug

    recipe_name = recipe_selections.find { |rank, _item| DRSkill.getrank(WOD.rank_map[wod_disc]) <= rank }.last # Selects first recipe with rank threshold higher than your current skill.
    echo "recipe_name is #{recipe_name}" if @debug

    item = DRCC.recipe_lookup(get_data('recipes')[discipline], recipe_name) # populates recipe data from base-recipes for a given item selected above
    echo "Recipe information for #{recipe_name}: #{item}" + debug_line if @debug

    quantity = (34 - DRSkill.getxp(WOD.rank_map[wod_disc])) / 10 # sets quantity based on current mindstate, max of 3 items.
    @items_remaining = quantity # for disposal of stock/parts if we hit our mindstate early

    unless quantity > 0 # mindstate of 25 or greater ends the training prematurely
      DRC.message("Current mindstate in #{WOD.rank_map[wod_disc]} is #{DRSkill.getxp(WOD.rank_map[wod_disc])}, which is above training threshold of 24. Exiting")
      exit
    end

    craft_method, book, script, base, tools, @belt, @work_room, materials_info = set_discipline_info(wod_disc, item, quantity)

    DRC.message("Crafting #{item['name']} #{quantity} times to train #{WOD.rank_map[wod_disc]} from #{DRSkill.getxp(WOD.rank_map[wod_disc])}/34")

    withdraw_funds(item, book, quantity, base, materials_info)

    send(craft_method, info, materials_info, item, quantity, book, script, base)

    DRCI.stow_hands

    if @workorders_repair && @workorders_repair_own_tools
      DRC.wait_for_script_to_complete('repair', ['self_repair', *tools])
    elsif @workorders_repair
      DRC.wait_for_script_to_complete('repair', tools)
    end
  end

  def work_order(discipline)
    ##################  SETTING DEFAULTS  ##################

    wod_disc = discipline # copying this variable for later modification

    if discipline == 'carving'
      wod_disc = [@carving_type, discipline].join('_')
      echo "wod_disc set as #{wod_disc} for the purposes of carving recipes" + debug_line if @debug
    elsif discipline == 'leatherworking'
      discipline = 'tailoring'
    end

    recipes = if @recipe_overrides[wod_disc]
                get_data('recipes')[discipline].select { |recipe| @recipe_overrides[wod_disc].find { |name| recipe['name'] =~ /#{name}/i } }
              else
                get_data('recipes')[discipline].select { |recipe| recipe['work_order'] }
              end

    info = if discipline =~ /weaponsmithing|armorsmithing/i
             @crafting_data['blacksmithing'][@hometown]
           elsif discipline == 'leatherworking'
             @crafting_data['tailoring'][@hometown]
           elsif discipline == 'tinkering'
             @crafting_data['shaping'][@hometown]
           else
             @crafting_data[discipline][@hometown]
           end

    recipes = discipline == 'carving' ? recipes.select { |x| x['material'] == @carving_type } : recipes

    ##################  VERIFY SETTINGS ##################

    case @settings.workorder_diff[wod_disc]
    when nil
      case @settings.workorder_diff
      when nil
        echo "Setting difficulty to Challenging" + debug_line if @debug
      when 'easy', 'challenging', 'hard'
        echo "Difficulty set at: #{@settings.workorder_diff}" + debug_line if @debug
      when 'career'
        echo "Difficulty requested is career, but this only works for training option. Reverting to hard" + debug_line if @debug
        @settings.workorder_diff = 'hard'
      else
        DRC.message("Invalid difficulty: #{@settings.workorder_diff}. Options include easy, challenging, or hard. Defaulting to Challenging")
        @settings.workorder_diff = 'challenging'
      end
    when 'easy', 'challenging', 'hard'
      echo "Difficulty set at: #{@settings.workorder_diff[wod_disc]}" + debug_line if @debug
    when 'career'
      echo "Difficulty requested is career, but this only works for training option. Reverting to hard" + debug_line if @debug
      @settings.workorder_diff[wod_disc] = 'hard'
    else
      DRC.message("Invalid difficulty: #{@settings.workorder_diff[wod_disc]}. Options include easy, challenging, or hard. Defaulting to Challenging")
      @settings.workorder_diff[wod_disc] = 'challenging'
    end

    ##################  SELECT RECIPE  ##################

    if @settings.workorder_diff.is_a?(Hash) && @settings.workorder_diff[wod_disc]
      item_name, quantity = request_work_order(recipes, info['npc-rooms'], info['npc'], info['npc_last_name'], discipline, info['logbook'], @settings.workorder_diff[wod_disc])
    elsif @settings.workorder_diff.is_a?(String)
      item_name, quantity = request_work_order(recipes, info['npc-rooms'], info['npc'], info['npc_last_name'], discipline, info['logbook'], @settings.workorder_diff)
    else
      item_name, quantity = request_work_order(recipes, info['npc-rooms'], info['npc'], info['npc_last_name'], discipline, info['logbook'], 'challenging')
    end

    item = DRCC.recipe_lookup(get_data('recipes')[discipline], item_name)

    ##################  DRAFT WORKORDER  ##################

    craft_method, book, script, base, tools, @belt, @work_room, materials_info = set_discipline_info(wod_disc, item, quantity)

    echo "Crafting #{item['name']} #{quantity} times to train #{WOD.rank_map[wod_disc]} for that sexy PRESTIGE"

    ##################  EXECUTE WORKORDER  ##################

    withdraw_funds(item, book, quantity, base, materials_info)

    send(craft_method, info, materials_info, item, quantity, book, script, base)

    complete_work_order(info)

    ##################  WRAP UP AND REPAIR  ##################

    if @workorders_repair && @workorders_repair_own_tools
      DRC.wait_for_script_to_complete('repair', ['self_repair', *tools])
    elsif @workorders_repair
      DRC.wait_for_script_to_complete('repair', tools)
    end
  end

  def set_discipline_info(discipline, item, quantity)
    craft_method, book, script, base = [:craft_prep, '', '', '']
    case discipline
    when 'blacksmithing', 'weaponsmithing', 'armorsmithing'
      book, script, base = ['forging', 'smith', 'ingot']
      materials_info = find_appropriate_ingot_size(item, quantity) # this gives us @scrap, @remainder, hash {order#, orderamount}
      # materials_info = @crafting_data['stock'][@workorders_materials['metal_type']]
      tools, @belt = [@settings.forging_tools, @settings.forging_belt]
      craft_method = :forge_prep
    when 'tailoring'
      book, script = ['outfitting', 'sew']
      tools, @belt, @work_room = [@settings.outfitting_tools, @settings.outfitting_belt, @settings.outfitting_room]
      if item['chapter'] == 5
        base = 'yarn'
        materials_info = @crafting_data['stock'][@workorders_materials['knit_type']]
      elsif [2, 3, 4].include?(item['chapter'])
        base = 'cloth'
        materials_info = @crafting_data['stock'][@workorders_materials['fabric_type']]
      end
    when 'leatherworking'
      book, script = ['outfitting', 'sew']
      tools, @belt, @work_room = [@settings.outfitting_tools, @settings.outfitting_belt, @settings.outfitting_room]
      base = 'leather'
      materials_info = @crafting_data['stock'][@workorders_materials['leather_type']]
    when 'shaping'
      book, script, base = ['engineering', 'shape', 'lumber']
      materials_info = @crafting_data['stock'][@workorders_materials['wood_type']]
      tools, @belt, @work_room = [@settings.shaping_tools, @settings.engineering_belt, @settings.engineering_room]
    when 'carving'
      book, script = ['engineering', 'carve']
      if @carving_type == 'bone'
        base = 'stack'
        materials_info = @crafting_data['stock'][@workorders_materials['bone_type']]
      else
        materials_info = @crafting_data['stock'][@workorders_materials['stone_type']]
        craft_method = :stone_prep
      end
      tools, @belt, @work_room = [@settings.carving_tools, @settings.engineering_belt, @settings.engineering_room]
    when 'remedies'
      book, script, materials_info, craft_method = ['alchemy', 'slim-remedy', @crafting_data['stock'], :remedy_prep]
      tools, @belt, @work_room = [@settings.alchemy_tools, @settings.alchemy_belt, @settings.alchemy_room]
    when 'artificing'
      book, script, materials_info, craft_method = ['enchanting', 'enchant', @crafting_data['stock'], :enchant_prep]
      tools, @belt, @work_room = [@settings.enchanting_tools, @settings.enchanting_belt, @settings.enchanting_room]
    end

    [craft_method, book, script, base, tools, @belt, @work_room, materials_info]
  end

  def withdraw_funds(item, book, quantity, base, materials_info)
    total_cost = DRCC.crafting_cost(item, @hometown, book == 'alchemy' ? item['part'] + ['alcohol', 'water', 'coal'] : item['part'], quantity, (book =~ /alchemy|enchanting/i) || (book == 'forging' && @workorders_materials['custom'][base]) ? false : materials_info)
    total_cost += 5000 if @workorders_repair
    DRCM.ensure_copper_on_hand(total_cost, @settings, @hometown)
  end

  ################           WORK SECTION            ######################

  def craft_prep(info, materials_info, item, quantity, book, script, base)
    unless @workorders_materials['custom'][base] && check_own_materials(item, quantity, @workorders_materials['custom'][base], base)
      type = materials_info['stock-name']
      base_to_buy, scrap = calc_stock(materials_info, item, quantity, base)
      buy_material_stackables(info, materials_info, base_to_buy, base) if base_to_buy
    else
      type = @workorders_materials['custom'][base]
      DRCI.put_away_item?("#{type} #{base}", @bag)
    end

    order_parts(item['part'], quantity) if item['part']
    DRCC.find_shaping_room(@hometown, @work_room)
    quantity.times do
      if @skip_logging
        training_monitor(script, [item['chapter'], item['name'], type, item['noun']], book, item['noun'])
        break if training_done?(book, item['part'], base, type)
      else
        break unless check_logbook_count(book)

        DRC.wait_for_script_to_complete(script, [item['chapter'], item['name'], type, item['noun']])
        DRCC.logbook_item(book, item['noun'], @bag)
      end
    end

    if @workorders_materials['custom'][base]
      method = :deed_item
    else
      if scrap && !@retain_crafting_materials
        method = :trash_crafting_item
      elsif scrap
        method = :deed_item
      end
    end
    while method && DRCI.get_item?("#{type} #{base}", @bag)
      send(method, "#{type} #{base}")
    end
  end

  def stone_prep(info, materials_info, item, quantity, book, script, _base)
    buy_material_singles(info, materials_info, quantity)
    order_parts(item['part'], quantity) if item['part']
    DRCC.find_shaping_room(@hometown)
    quantity.times do
      break unless check_logbook_count(book)

      DRC.wait_for_script_to_complete(script, [item['chapter'], item['name'], materials_info['stock-name'], item['noun']])
      DRCC.logbook_item(book, item['noun'], @bag)
    end
  end

  def remedy_prep(info, materials_info, item, quantity, book, _script, base)
    @leftovers = buy_remedies(info, materials_info, item, quantity)
    @bag_items << @leftovers
    DRCT.walk_to(@work_room)
    quantity.times do
      DRC.wait_for_script_to_complete('slim-remedy', [item['name']])
      name = DRC.right_hand
      if @skip_logging
        DRCI.dispose_trash(name, @settings.worn_trashcan, @settings.worn_trashcan_verb)
        break if training_done?(book, @leftovers, base)
      else
        break if finished_remedies(name) >= quantity * 5

        DRCC.stow_crafting_item(name, @bag, nil)
      end
    end
    log_remedy(item['noun'], quantity) unless @skip_logging
    @leftovers.each do |part|
      while DRCI.get_item?(part, @bag)
        trash_crafting_item(part)
      end
    end
  end

  def enchant_prep(info, materials_info, item, quantity, book, _script, base)
    item['part'].each do |part|
      buy_material_singles(info, materials_info[part], quantity, part)
    end
    DRCC.fount(info['tool-room'], 1, info['fount'], quantity, @bag, @bag_items, @belt)
    DRCI.put_away_item?("fount", @bag)
    # Start crafting #
    DRCC.find_enchanting_room(@hometown, @work_room)
    quantity.times do
      if @skip_logging
        DRC.wait_for_script_to_complete('enchant', [item['chapter'], item['name'], item['noun']])
        DRCI.dispose_trash(item['noun'], @settings.worn_trashcan, @settings.worn_trashcan_verb)
        break if training_done?(book, item['part'], base)
      else
        DRC.wait_for_script_to_complete('enchant', [item['chapter'], item['name'], item['noun']])
        DRCC.logbook_item('enchanting', item['noun'], @bag)
      end
    end
  end

  def forge_prep(info, materials_info, item, quantity, book, script, base)
    info['stock-room'] = info['bingots-room'] if @bingot
    if @workorders_materials['custom'][base]
      if check_own_ingot(item, quantity, @workorders_materials['custom'][base])
        type = @workorders_materials['custom'][base]
      else
        @workorders_materials['custom'][base] = false # to escape the return for personal materials
        materials_info = find_appropriate_ingot_size(item, quantity) # getting our bingots/ingots info
        return forge_prep(info, materials_info, item, quantity, book, script, base) # rerun prep, this time with the stock ingot information.
      end
    elsif @bingot == 1 # only purchasing one, so lets just grab it now
      buy_material_singles(info, materials_info, @bingot)
    elsif !@bingot # we've already gotten our info from the find_appropriate method, and if we're not doing bingots, we're doing regular ol' ingots.
      buy_material_singles(info, materials_info, @ingot_count) # buying however many ingots we need
    end
    type ||= materials_info['stock-name']
    quantity.times do
      # this variable is truthy, contains the number of bingots we're purchasing, and has already checked we can purchase them. doing the purchase here to prevent loading more than one of these in our bag
      buy_material_singles(info, materials_info, @bingot) if @bingot == quantity # we're using one bingot for each item, so we'll buy them one at a time.
      if @skip_logging
        training_monitor(script, [type, item['name']], book, item['noun'])
        break if training_done?(book, item['part'], base, type)
      else
        break unless check_logbook_count("forging")

        DRC.wait_for_script_to_complete('smith', [type, item['name']])
        DRCC.logbook_item('forging', item['noun'], @bag)
      end
      if @scrap
        DRCI.get_item?("#{type} #{base}", @bag)
        DRCI.dispose_trash("#{type} #{base}", @settings.worn_trashcan, @settings.worn_trashcan_verb)
      end
    end
    if @remainder && DRCI.get_item?("#{type} #{base}", @bag) # remainder from the use of a single ingot
      DRCI.dispose_trash("#{type} #{base}", @settings.worn_trashcan, @settings.worn_trashcan_verb)
    end
    smelt(type) if @smelt
    deed_item("#{type} #{base}") if @workorders_materials['custom'][base]
  end

  def check_logbook_count(craft)
    /(\d)/ =~ DRC.bput("read my #{craft} logbook", /This work order appears to be complete/, /You must bundle and deliver (\d+) more/, /^This logbook is not currently tracking any work orders/)
  end

  def training_monitor(script, args, book, name)
    verify_script(script)
    start_script(script, args.map { |arg| arg.to_s =~ /\s/ ? "\"#{arg}\"" : arg })
    pause 30

    @counter ||= 0
    @counter += 30
    loop do
      if Script.running?(script) && DRSkill.getxp(book.capitalize) == 34
        DRC.message("Stopping #{script} after #{@counter / 60} minutes because #{book.capitalize} is mindlocked")
        stop_script(script)
        stop_script("forge") if Script.running?("forge")
        pause 1 while Script.running?(script)
        break
      elsif Script.running?(script)
        @counter += 1
        pause 1
        next
      end
      DRCI.dispose_trash(name, @settings.worn_trashcan, @settings.worn_trashcan_verb)
      return
    end

    case book
    when /forging/
      [DRC.left_hand, DRC.right_hand].each do |tool|
        DRCC.stow_crafting_item(tool, @bag, @belt) if @settings.forging_tools.include?(tool)
      end
      DRCC.clean_anvil?
      DRCI.dispose_trash(name, @settings.worn_trashcan, @settings.worn_trashcan_verb) if DRCI.in_hands?(name)
    when /enchanting/
      DRCC.clean_brazier?
      [DRC.left_hand, DRC.right_hand].each do |tool|
        DRCC.stow_crafting_item(tool, @bag, @belt) if @settings.enchanting_tools.include?(tool)
      end
      2.times do fput("empty feet") end
    else
      DRCC.stow_crafting_item(DRC.right_hand, @bag, @belt)
      DRCC.stow_crafting_item(DRC.right_hand, @bag, @belt) if DRCI.lift?
      DRCI.dispose_trash(DRC.left_hand, @settings.worn_trashcan, @settings.worn_trashcan_verb) if checkleft
    end
  end

  def training_done?(book, parts, base, type = '')
    @items_remaining -= 1 # reduce remaining by 1 each time we come here, reflecting a completed use of materials.
    return false unless DRSkill.getxp(book.capitalize) > 28 # not yet at our mindstate goal
    return false if @items_remaining <= 0 # met our mindstate goal, but also finished using our materials

    DRC.message("Stopping #{book.capitalize} training after #{@counter / 60} minutes because #{book.capitalize} is above training threshold of 28")

    parts.each do |part| # dumping all excess parts, this covers all of enchanting/remedies
      while DRCI.get_item?(part, @bag)
        DRCI.dispose_trash(part, @settings.worn_trashcan, @settings.worn_trashcan_verb)
      end
    end
    # don't trash stock materials if doing remedies|artificing(no stock materials to trash), if we're using custom materials(we'll be deeding remainder), or if we've specifically elected to retain them.
    return true if book =~ /enchanting|alchemy/i || @workorders_materials['custom'][base] == type || @retain_crafting_materials

    while DRCI.get_item?("#{type} #{base}", @bag)
      DRCI.dispose_trash("#{type} #{base}", @settings.worn_trashcan, @settings.worn_trashcan_verb)
    end
    true
  end

  ################        MATERIALS HANDLING         ######################

  def find_appropriate_ingot_size(item, quantity)
    return if @workorders_materials['custom']['ingot'] # Using our own materials. We'll revisit this if we're out

    total_volume = quantity * item['volume']
    @scrap, @remainder, @bingot, @ingot_count = [false, false, false, quantity]
    order = [50, 100, 200]
    case @workorders_materials['metal_type']
    when /bronze/i
      if item['volume'] == 5 # exactly one ingot per item, so no scrap
        return @crafting_data['stock'][@workorders_materials['metal_type']]
      elsif total_volume <= 5 # all items within one 5 volume bronze ingot
        @remainder = 5 % total_volume
        @ingot_count = 1 # number of regular ingots to purchase
        return @crafting_data['stock'][@workorders_materials['metal_type']]
      elsif item['volume'] < 5 && total_volume < 25 # each item fits inside one small ingot, and we're using less than half of a bingot
        @scrap = 5 % item['volume']
        return @crafting_data['stock'][@workorders_materials['metal_type']]
      end
    when /steel/i
      if item['volume'] == 10 # exactly one ingot per item, so no scrap
        return @crafting_data['stock'][@workorders_materials['metal_type']]
      elsif total_volume <= 10 # all items within one 10 volume steel ingot
        @remainder = 10 % total_volume
        @ingot_count = 1
        return @crafting_data['stock'][@workorders_materials['metal_type']]
      elsif item['volume'] < 10 && total_volume < 25 # each item fits inside one small ingot, and we're using less than half of a bingot
        @scrap = 10 % item['volume']
        return @crafting_data['stock'][@workorders_materials['metal_type']]
      end
    when /tin/i # Always using bingots here, since normal tin is 1 volume, and they're nuggets, so you'd have to smelt
      tin = true
      if item['volume'] > 100 && bingots_available?
        DRC.message("#{item['name']} requires #{item['volume']}, which is too large to use stock tin, reverting to iron")
        @workorders_materials['metal-type'] = 'iron'
        return find_appropriate_ingot_size(item, quantity)
      elsif total_volume > 100 && bingots_available? # item can fit inside a gigantic ingot, but we'll need more than one
        # do nothing, this is handled in bingots section
      elsif !bingots_available? # no bingots, not using custom materials, so no bueno on tin
        DRC.message("Tin is not available at your location")
        if item['volume'] <= 10
          @workorders_materials['metal-type'] = 'steel'
          return @crafting_data['stock'][@workorders_materials['metal_type']]
        else
          DRC.message("#{item['name']} requires an ingot of at least #{item['volume']} which exceeds the supplies available at this location. Please change your recipe choice, or craft somewhere else")
          exit
        end
      end
    when /iron/i # always using bingots here, since normal iron is nuggets
      # do nothing, going to bingots
    end

    unless bingots_available?
      echo "No bingots available at your hometown, using standard ingots"
      if @workorders_materials['metal_type'] =~ /tin|iron/i
        @workorders_materials['metal_type'] = 'steel'
        return find_appropriate_ingot_size(item, quantity)
      else
        return @crafting_data['stock'][@workorders_materials['metal_type']]
      end
    end

    ################  BEWARE THE BINGOTS  ####################

    if total_volume <= 50 # all items within the immense ingot
      @remainder = 50 % total_volume
      @bingot, size = [1, 0] # immense, purchase 1
    elsif total_volume <= 100 # all items within the gigantic ingot
      @remainder = 100 % total_volume
      @bingot, size = [1, 1] # gigantic, purchase 1
    elsif total_volume <= 200 && !tin # all items within the colossal ingot, minus tin (no 200v tin ingots)
      @remainder = 200 % total_volume
      @bingot, size = [1, 2] # colossal, purchase 1
    elsif item['volume'] <= 50 # one item fits inside the immense ingot
      @scrap = 50 % item['volume']
      @bingot, size = [quantity, 0] # immense, purchase 1 per item
    elsif item['volume'] <= 100 # one item fits inside the gigantic ingot
      @scrap = 100 % item['volume']
      @bingot, size = [quantity, 1] # gigantic, purchase 1 per item
    elsif item['volume'] <= 200 # one item fits inside the colossal ingot. This should be everything else, mostly armorsmithing
      @scrap = 200 % item['volume']
      @bingot, size = [quantity, 2]
    end
    @crafting_data['stock'][@workorders_materials['metal_type'] + order[size].to_s] # populates materials info from the bingots groups
  end

  def bingots_available?
    @crafting_data['blacksmithing'][@hometown]['bingots-room']
  end

  def buy_material_singles(info, materials_info, quantity, name = '')
    # Buy single, non-stackable materials eg rock deeds, ingots, herbs
    quantity.times do
      if materials_info['stock-number']
        DRCT.order_item(info['stock-room'], materials_info['stock-number'])
        DRCC.stow_crafting_item([DRC.left_hand, DRC.right_hand].compact.first, @bag, nil)
      else
        DRCT.buy_item(info['stock-room'], name)
        DRCC.stow_crafting_item(name, @bag, nil)
      end
    end
  end

  def buy_material_stackables(info, materials_info, base_to_buy, base)
    # Buy stackable materials eg lumber/bone stacks
    # Total volume for max count workorder needs to be under total stackable size
    base_to_buy.times do
      DRCT.order_item(info['stock-room'], materials_info['stock-number'])
      fput("combine #{base}")
    end
    DRCC.stow_crafting_item(base, @bag, nil)
  end

  def buy_remedies(info, materials_info, item, quantity)
    herb_list = ['crushed flowers', 'muljin', 'belradi', 'dioica', 'hulnik', 'aloe', 'eghmok', 'lujeakave', 'yelith', 'cebi', 'blocil', 'hulij', 'nuloe', 'hisan']
    item['part'].each do |part|
      if herb_list.include?(part)
        needed = part.split(' ').last
        collect_and_process(item, needed, quantity)
        item['part'].shift # Update our parts list to remove the herb we've already purchased
      else
        quantity.times { buy_material_singles(info, materials_info[part], 1, part) } # Buy one  main herb stack for each remedy to craft
      end
    end
    item['part'] += ['water', 'alcohol'] # add the bits we might need to parts array for purchase and disposal
    item['part'].each { |part| buy_material_singles(info, materials_info[part], 1, part) } # purchase one of each of these bits
    buy_material_singles(get_data('crafting')['blacksmithing'][@hometown], materials_info['coal'], 1, 'nugget') && item['part'] += ['coal nugget'] # Buy a single coal nugget, plenty, and add it to our parts list
    return item['part'] # Return a list of parts for disposal at the end.
  end

  def finished_remedies(name)
    type, base = name.split(' ')
    while DRCI.get_item?("#{type} #{base}", @bag)
      fput("combine")
    end
    return material_volume(type, base)
  end

  def calc_stock(materials_info, recipe, quantity, base = '')
    total_needed = quantity * recipe['volume']
    if (on_hand_stock = check_own_materials(recipe, quantity, materials_info['stock-name'], base)) # If we have enough materials, returns a value for on_hand_stock. otherwise returns false.
      scrap = total_needed == on_hand_stock ? false : true
      DRCI.put_away_item?("#{materials_info['stock-name']} #{base}", @bag)
      return [false, scrap] # have what we need, no need to buy
    elsif DRCI.get_item?("#{materials_info['stock-name']} #{base}", @bag)
      /(\d+)/ =~ DRC.bput("count my #{materials_info['stock-name']} #{base}", /^You count out (\d+) (pieces|yards) of (lumber|material)/)
      on_hand_stock = Regexp.last_match(1).to_i
      if on_hand_stock >= (total_needed) # We have what we need, so no need to buy more.
        DRCC.stow_crafting_item("#{materials_info['stock-name']} #{base}", @bag, @belt)
        scrap = (total_needed) % materials_info['stock-volume'] > 0 ? true : false
        return [base, scrap]
      end
      total_needed -= on_hand_stock # How many do we need to buy to add to what we already have.
    end

    base_to_buy = (total_needed / materials_info['stock-volume'].to_f).ceil
    scrap = (total_needed) % materials_info['stock-volume'] > 0 ? true : false

    [base_to_buy, scrap]
  end

  ################          PARTS HANDLING           ######################

  def buy_parts(parts, partroom)
    parts.each do |part|
      DRCT.buy_item(partroom, part)
      DRCC.stow_crafting_item(part, @bag, @belt)
    end
  end

  def order_parts(parts, quantity)
    parts.each do |part|
      data = @recipe_parts[part][@hometown]
      quantity.times do
        if data['part-number']
          DRCT.order_item(data['part-room'], data['part-number'])
        else
          DRCT.buy_item(data['part-room'], part)
        end
        DRCC.stow_crafting_item(part.split.last, @bag, @belt)
      end
    end
  end

  def trash_crafting_item(trash)
    DRCT.walk_to(@crafting_data['blacksmithing'][@hometown]['trash-room']) unless @settings.worn_trashcan
    DRCI.dispose_trash(trash, @settings.worn_trashcan, @settings.worn_trashcan_verb)
  end

  ################    PERSONAL MATERIALS HANDLING    ######################

  def collect_and_process(recipe, herb_needed, quantity) # can require significant outdoorsmanship skill and somewhat careful selection of an outdoors room. Alternative is just foraging and processing your own.
    unless @workorders_collect_herbs
      quantity.times { DRCC.stow_crafting_item(DRC.left_hand, @bag, nil) if redeem_deed(herb_needed) }
      return
    end
    forage_name = ['muljin sap', 'belradi moss', 'dioica sap', 'hulnik grass', 'aloe leaves', 'eghmok moss', 'lujeakave root', 'yelith root', 'cebi root', 'blocil berries', 'hulij leaves', 'nuloe stem', 'hisan flower']
    herb = forage_name.find { |h| h.include?(herb_needed) } || 'blue flower' # crushed flowers is the special case here, so unless we find a match, it defaults to blue flowers.
    DRCT.walk_to(@settings.outdoors_room)
    flowers, needed = [0, quantity] # number of individual flower stacks, representing 1 does, and 25 count stacks, representing 5 doses
    until flowers >= 5 * quantity
      case DRC.bput("collect #{herb}", /^You manage to collect/, /^You.*(forage|wander) around/, /^You find something dead/, /too cluttered/)
      when /You.*(forage|wander) around/, /You find something dead/
        DRC.message("Failed to collect #{herb}. Either it cannot be found here or you don't have the skill to collect it.\nYou will have to collect your own herbs for this recipe going forwards.\nChange yaml setting: workorders_collect_herbs to false.")
        exit
      when /too cluttered/
        fput("dump junk")
        pause 60
        redo
      end
      until /(There doesn't seem to be anything left in the pile|You pick up)/ =~ DRC.bput("get #{herb}", /^You get.*a pile on the ground/, /^You pick up/, /^There doesn't seem to be anything left in the pile/)
        DRCC.stow_crafting_item(herb, @bag, @belt)
        flowers += 1
      end
      if checkright
        DRCC.stow_crafting_item(herb, @bag, @belt)
        flowers += 1
      end
    end
    DRCT.walk_to(get_data('crafting')['remedies'][@hometown]['press-grinder-rooms'].first)
    process = recipe['container'] == 'bowl' ? "put my #{herb} in grinder" : "put my #{herb} in press"
    quantity.times do
      5.times do
        DRCI.get_item?(herb, @bag)
        DRC.bput(process, /^You place some/)
        DRC.bput("combine", /^You must be holding/, /^You combine/)
        flowers -= 1
      end
      DRCC.stow_crafting_item(DRC.left_hand, @bag, nil)
      needed -= 1
    end
    until /referring/ =~ DRC.bput("get my #{herb}", /^You get/, /^You are already/, /^You're already/, /What were you referring to/)
      DRCI.dispose_trash(herb, @settings.worn_trashcan, @settings.worn_trashcan_verb)
    end
  end

  def redeem_deed(deed_type, base = '')
    if DRCI.get_item?("#{@ordinals.first} #{deed_type} deed", @workorders_deed_storage)
      case DRC.bput("tap my deed", /^An attendant arrives/, /^The worker explains/, /^The deed appears to be redeemable only in one of the Crafting Society Halls/)
      when /explains/
        DRCC.stow_crafting_item('deed', @workorders_deed_storage, nil)
        @ordinals.shift
        return redeem_deed(deed_type, base)
      when /The deed appears to be redeemable only in one of the Crafting Society Halls/
        DRCC.stow_crafting_item('deed', @workorders_deed_storage, nil)
        DRCT.walk_to(@crafting_data['blacksmithing'][@hometown]['stock-room'])
        return redeem_deed(deed_type, base)
      end
      pause 0.5
      DRCI.lift?("#{deed_type} #{base}")
      true
    else
      DRC.message("Missing the required deeds for #{deed_type}")
      false
    end
  end

  def deed_item(item)
    if /I could not find/ =~ DRC.bput('look my deed packet', /You count \d+ deed claim forms remaining/, /I could not find what you were referring to/)
      DRCM.ensure_copper_on_hand(@cash_on_hand || 10_000, @settings, @hometown)
      DRCT.order_item(@deeds_room, @deeds_number)
    end
    DRCI.get_item?("deed packet")
    DRCI.get_item_if_not_held?(item, @bag)
    DRC.bput("push my #{item} with packet", /^You push/)
    DRCC.stow_crafting_item("packet", @bag, nil)
    DRCC.stow_crafting_item("deed", @workorders_deed_storage, nil)
  end

  def ingot_volume(material)
    DRC.bput("analyze my #{material} ingot", /About \d+ volume/).scan(/\d+/).first.to_i
  end

  def material_volume(type, base)
    DRC.bput("count my #{type} #{base}", /^You count out (\d+) (pieces|uses|yards).*(lumber|remaining|material)/).scan(/\d+/).first.to_i
  end

  def deed_volume(material)
    result = DRC.bput("read my #{material} deed", /Volume:\s*\d+/, /Amount:\s*\d+/, /Pieces:\s*\d+/)
    case result
    when /\d+/
      result.scan(/\d+/).first.to_i
    else
      false
    end
  end

  def check_own_materials(item, quantity, type, base)
    volume = 0
    while volume < (item['volume'] * quantity)
      if DRCI.get_item?("#{type} #{base}", @bag)
        # fput('combine')
        if /too large/ =~ DRC.bput("combine", /^You combine/, /^You must be holding both substances/, /^That .* is too large to add more to/, /^The resulting stack of .*would be too large and unwieldy/)
          # here we're stowing the first piece we had, which was too small
          # The problem we can run into is with an order over half the size of a fresh deed,
          # but we have two stacks which are both over half (can't combine) while neither are sufficient size
          # It's not clear there is an elegant fix for this, the hope is it just doesn't crop up often enough
          DRCI.put_away_item?("second #{type} #{base}", @bag)
        end
        volume = material_volume(type, base)
        next
      end
      if volume < (item['volume'] * quantity)
        if redeem_deed(type, base)
          if [DRC.right_hand, DRC.left_hand].compact.size > 1
            if /too large/ =~ DRC.bput("combine", /^You combine/, /^You must be holding both substances/, /^That .* is too large to add more to/, /^The resulting stack of .*would be too large and unwieldy/)
              # here we're stowing the first piece we had, which was too small
              # The issue is when redeeming a new deed, it's likely to be a full stack
              # so we want to just use the full stack, and we'll try combining them next time.
              DRCI.put_away_item?("second #{type} #{base}", @bag)
            end
          end
          volume = material_volume(type, base)
        else
          DRC.message("Out of #{base} and deeds")
          [DRC.right_hand, DRC.left_hand].each { |thing| thing =~ /deed/i ? DRCC.stow_crafting_item("deed", @workorders_deed_storage, nil) : DRCC.stow_crafting_item(thing, @bag, @belt) }
          return false
        end
      end
    end
    return volume
  end

  def check_own_ingot(item, quantity, type)
    unless DRCI.get_item?("#{type} ingot", @bag)
      if (volume = deed_volume(type))
        redeem_deed(type, 'ingot')
      else
        echo('out of material/deeds')
        return false
      end
    end

    volume ||= ingot_volume(type)

    DRCI.put_away_item?("#{type} ingot", @bag)
    @smelt = false

    if volume < (quantity * item['volume'])
      @smelt = true
      if (volume = deed_volume(type))
        redeem_deed(type, 'ingot')
      else
        echo('out of material/deeds')
        DRCI.put_away_item?("#{type} ingot", @bag)
        return false
      end
    end

    if volume < (quantity * item['volume'])
      echo('out of material/deeds')
      smelt(type)
      return check_own_ingot(item, quantity, type)
    end

    true
  end

  def smelt(type)
    DRCC.find_empty_crucible(@hometown)
    2.times do
      DRCI.get_item?("#{type} ingot", @bag)
      DRCI.put_away_item_unsafe?("#{type} ingot", "crucible")
    end
    DRC.wait_for_script_to_complete('smelt')
  end

  ################       TASK MASTER HANDLING        ######################

  def request_work_order(recipes, npc_rooms, npc, npc_last_name, discipline, logbook, diff)
    match_names = recipes.map { |x| x['name'] }
    diff ||= 'challenging'
    [DRC.right_hand, DRC.left_hand].compact.each { |thing| DRCI.put_away_item?(thing, @bag) }
    500.times do
      find_npc(npc_rooms, npc_last_name)
      DRCC.get_crafting_item("#{logbook} logbook", @bag, @bag_items, @belt) unless DRCI.in_hands?('logbook')
      case DRC.bput("ask #{npc} for #{diff} #{discipline} work", '^To whom', 'order for .* I need \d+ ', 'order for .* I need \d+ stacks \(5 uses each\) of .* quality', 'You realize you have items bundled with the logbook', 'You want to ask about shadowlings')
      when 'You want to ask about shadowlings'
        pause 10
        fput('say Hmm.')
      when /order for (.*)\. I need (\d+) /
        item = Regexp.last_match(1)
        quantity = Regexp.last_match(2).to_i
        if @min_items <= quantity && quantity <= @max_items && match_names.include?(item)
          DRCC.stow_crafting_item("#{logbook} logbook", @bag, @belt)
          return [item, quantity]
        end
      when /order for (.*)\. I need (\d+) stacks \(5 uses each\) of .* quality/
        item = Regexp.last_match(1)
        quantity = Regexp.last_match(2).to_i
        if @min_items <= quantity && quantity <= @max_items && match_names.include?(item)
          DRCC.stow_crafting_item("#{logbook} logbook", @bag, @belt)
          return [item, quantity]
        end
      when 'You realize you have items bundled with the logbook'
        DRC.bput('untie my logbook', 'You untie')
        trash = [DRC.left_hand, DRC.right_hand].find { |thing| thing !~ /logbook/i }
        DRCI.dispose_trash(trash, @settings.worn_trashcan, @settings.worn_trashcan_verb)
      end
    end
    DRCC.stow_crafting_item('logbook', @bag, @belt)
    DRC.message("Failed to find a qualifying order based on your current settings.")
    exit
  end

  def log_remedy(name, quantity)
    return unless name

    quantity.times do
      if /You trace an X/ =~ DRC.bput("mark my #{name} at 5", /^You measure out/, /^There is not enough/, /^You must be holding/, /^You trace an X across your chest/) # if we have exactly the number required, the last remedy won't mark
        DRC.message("Missing the finished product for some reason, aborting log routine")
        return
      end
      DRC.bput("break my #{name}", /^You carefully break off/, /^You can't break that/) # and won't break. Bundles fine.
      DRCC.stow_crafting_item(name, @bag, @belt)
    end
    mod = ''
    if checkleft
      mod = 'second '
      DRCC.stow_crafting_item(name, @bag, @belt)
    end
    DRCC.get_crafting_item("alchemy logbook", @bag, @bag_items, @belt)
    quantity.times do
      DRCI.get_item("#{mod}#{name}", @bag)
      unless /You notate the/ =~ DRC.bput("bundle my #{name} with my logbook", /^You notate the/, /^Th(at|e|is) (work order|isn\'t the correct) (has expired|requires items|type of item)/, /^You notice the work ?order/)
        DRCI.dispose_trash(name, @settings.worn_trashcan, @settings.worn_trashcan_verb)
      end
    end
    DRC.bput("put my alchemy logbook in my #{@bag}", 'You put', 'What were you referring to')
  end

  def complete_work_order(info)
    [DRC.right_hand, DRC.left_hand].compact.each { |item| DRCI.put_away_item?(item, @bag) }
    loop do
      find_npc(info['npc-rooms'], info['npc_last_name'])
      DRCC.get_crafting_item("#{info['logbook']} logbook", @bag, @bag_items, @belt)
      DRC.release_invisibility
      case DRC.bput("give my #{info['logbook']} logbook to #{info['npc']}", /You hand/, /You can/, /What were you/, /Apparently the work order time limit has expired/, /The work order isn\'t yet complete/, /What is it you\'re trying to give/)
      when /You can/, /What were you/, /What is it/
        next
      end
      break
    end
    DRCC.stow_crafting_item("#{info['logbook']} logbook", @bag, @belt)
  end

  def find_npc(room_list, npc)
    return if DRRoom.npcs.include?(npc)

    room_list.each do |room_id|
      break if DRRoom.npcs.include?(npc)

      DRCT.walk_to(room_id)
    end
  end

  def debug_line
    caller_line = caller.first.split(":")[1]
    ":Line:#{caller_line}"
  end
end

before_dying do
  Flags.delete('proper-repair')
end

WOD = WOData.new
WorkOrder.new
