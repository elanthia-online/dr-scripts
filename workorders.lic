=begin
  Documentation: https://elanthipedia.play.net/Lich_script_repository#workorders
=end

custom_require.call(%w[common common-crafting common-items common-money common-travel drinfomon events])

class WorkOrders

    def initialize
        arg_definitions = [
        [
            { name: 'discipline', options: %w[blacksmithing weaponsmithing tailoring shaping carving remedies artificing], description: 'What type of workorder to do?' },
            { name: 'train', regex: /train/i, optional: true, description: 'train a particular craft to high mindstate instead of doing a workorder for prestige' },
            { name: 'repair', regex: /repair/i, optional: true, description: 'repair tools instead of crafting' }
        ]
        ]

        args = parse_args(arg_definitions)
        @settings = get_settings
        @ordinals = $ORDINALS
        @crafting_data = get_data('crafting')
        @recipe_parts = @crafting_data['recipe_parts']
        @bag = @settings.crafting_container
        @bag_items = @settings.crafting_items_in_container
        @hometown = @settings.crafting_hometown || @settings.hometown
        @deeds_room = get_data('crafting').deeds[@hometown]['room']
        @deeds_number = get_data('crafting').deeds[@hometown]['medium_number']
        @carving_type = @settings.carving_workorder_material_type
        @min_items = @settings.workorder_min_items
        @max_items = @settings.workorder_max_items
        @recipe_overrides = @settings.workorder_recipes || {}
        @cash_on_hand = @settings.workorder_cash_on_hand
        @craft_max_mindstate = @settings.craft_max_mindstate
        @retain_crafting_materials = @settings.retain_crafting_materials
        @workorders_repair = @settings.workorders_repair
        @workorders_override_store = @settings.workorders_override_store
        @workorders_repair_own_tools = @settings.workorders_repair_own_tools
        @workorders_materials = @settings.workorders_materials
        @workorders_deed_storage = @settings.workorders_deed_storage || @bag
        @workorders_collect_herbs = @settings.workorders_collect_herbs
        Flags.add('proper-repair', 'Your excellent training in the ways of tool repair')
        DRC.wait_for_script_to_complete('safe-room', ['force']) if @settings.workorders_force_heal

        if args.train
            train_craft(args.discipline)
        else
            work_order(args.discipline, args.repair)
        end
    end

    def train_craft(discipline)
        @skip_logging = true

        # This can be a little confusing, the train_map should be read as "if skill in this craft is less than <rank>, craft this item". 
        # So once you hit 26 ranks in Outfitting(tailoring) you'll start crafting 'some knitted mittens' instead of 'some knitted socks'.
        train_map = {
            'tailoring'     => {25=>'some knitted socks',50=>'some knitted mittens',100=>'a knitted hat',200=>'some knitted gloves',300=>'some knitted hose',425=>'a knitted cloak',500=>'a cloth haversack',600=>'a deeply-hooded cloak',750=>"some flowing cloth robes",1000=>'a cloth mining belt',1400=>"a cloth survival belt",1750=>"a cloth artisan's belt"},
            'shaping'       => {25=>'a wood band',50=>'a wood bracelet',100=>'a wood cloak pin',200=>'a wood amulet',300=>'a wood brooch',425=>'a wood armband',500=>'a wood choker',600=>'an articulated wood necklace',750=>'a wood crown',1000=>'a wood comb',1400=>'a wood haircomb',1750=>'a detailed wood statue'},
            'blacksmithing' => {25=>'a shallow metal cup',50=>'a short metal mug',100=>'a back scratcher',200=>'a small metal flask',300=>'a metal lockpick ring',425=>'a metal armband',500=>'some metal clippers',600=>'a triangular wire sieve',750=>'a serrated hide scraper',1000=>'a metal mask',1400=>'some thin sewing needles',1750=>'a trapezoidal wire sieve'},
            'remedies'      => {25=>'some blister cream',50=>'some moisturizing ointment',100=>'some chest salve',200=>'a neck potion',300=>'some limb salve',425=>'some chest ungent',500=>'some neck tonic',600=>'some eye tonic',750=>'a body elixir',1000=>'a general elixir',1400=>'some refreshment elixir',1750=>'some vigor poultices'},
            'artificing'    => {25=>'a radiant trinket',50=>'a mana trinket',100=>'a wind trinket',200=>'an earth trinket',300=>'a fire trinket',425=>'a water trinket',500=>'simple gwethsmasher',600=>'a destructive focus',750=>'a fire focus',1000=>'a frost focus',1400=>'an electric focus',1750=>'an electric focus'}
          }
        # Key to translate discipline into actual skill to track for experience.
        rank_map = {'tailoring'=>'Outfitting','shaping'=>'Engineering','blacksmithing'=>'Forging','remedies'=>'Alchemy','artificing'=>'Enchanting'}
        
        unless train_map[discipline]
            DRC.message("#{discipline} is not currently supported for training option. Options include: tailoring, shaping, blacksmithing, remedies, and artificing.")
            exit
        end

        quantity = (34 - DRSkill.getxp(rank_map[discipline]))/10 # sets quantity based on current mindstate, max of 3 items.
        @items_remaining = quantity # for disposal of stock/parts if we hit our mindstate early

        unless quantity > 0 # mindstate of 25 or greater ends the training prematurely
            DRC.message("Current mindstate in #{discipline} is #{DRSkill.getxp(rank_map[discipline])}, which is above training threshold of 24. Exiting")
            exit
        end
        
        recipe_name = train_map[discipline].find { |rank,item| DRSkill.getrank(rank_map[discipline]) <= rank }.last # Selects first recipe with rank threshold higher than your current skill.
        info = @crafting_data[discipline][@hometown]
        item = get_data('recipes')[discipline].find { |recipe| recipe_name == recipe['name'] } # populates recipe data from base-recipes for a given item selected above
        craft_method,book,script,base,skill,tools,@belt,@work_room,materials_info = set_discipline_info(discipline, item)
        withdraw_funds(item, book, quantity, base, materials_info)

        DRC.message("Crafting #{item['name']} #{quantity} times to train #{rank_map[discipline]} from #{DRSkill.getxp(rank_map[discipline])}/34")
        
        send(craft_method, info, materials_info, item, quantity, book, script, base)

        DRCI.stow_hands

        if @workorders_repair && !@workorders_repair_own_tools
            DRCC.repair_tools(tools, @bag, @belt, @hometown, @settings)
        elsif @workorders_repair
            repair_own_tools(info, tools) if @workorders_repair_own_tools
        end        
    end

    def work_order(discipline, repair)
        recipes =   if @recipe_overrides[discipline]
                        get_data('recipes')[discipline].select { |recipe| @recipe_overrides[discipline].find { |name| recipe['name'] =~ /#{name}/i } }
                    else
                        get_data('recipes')[discipline].select { |recipe| recipe['work_order'] }
                    end

        info =      if discipline =~ /weaponsmithing|armorsmithing/i
                        @crafting_data['blacksmithing'][@hometown]
                    else
                        @crafting_data[discipline][@hometown]
                    end

        recipes = discipline == 'carving' ? recipes.select { |x| x['material'] == @carving_type } : recipes

        unless repair
            if @settings.workorder_diff.is_a?(Hash)
                item_name, quantity = request_work_order(recipes, info['npc-rooms'], info['npc'], info['npc_last_name'], discipline, info['logbook'], @settings.workorder_diff[discipline])
            else
                item_name, quantity = request_work_order(recipes, info['npc-rooms'], info['npc'], info['npc_last_name'], discipline, info['logbook'], @settings.workorder_diff)
            end
            item = recipes.find { |r| r['name'] == item_name }
        end
        
        craft_method,book,script,base,skill,tools,@belt,@work_room,materials_info = set_discipline_info(discipline, item)
        withdraw_funds(item, book, quantity, base, materials_info) unless repair

        if repair && @workorders_repair_own_tools
            repair_own_tools(info, tools)
            exit
        elsif repair
            DRCC.repair_tools(tools, @bag, @belt, @hometown, @settings)
            exit
        end

        send(craft_method, info, materials_info, item, quantity, book, script, base)

        DRCC.repair_tools(tools, @bag, @belt, @hometown, @settings, false) if @workorders_repair && !@workorders_repair_own_tools

        # tool_drop(get_data('crafting')['shaping'][@hometown], tools) if @workorders_repair && !@workorders_repair_own_tools

        complete_work_order(info)

        DRCC.pickup_tools(@bag, @belt, @hometown, @settings) if @workorders_repair && !@workorders_repair_own_tools

        # tool_pickup(get_data('crafting')['shaping'][@hometown]) if @workorders_repair && !@workorders_repair_own_tools

        repair_own_tools(info, tools) if @workorders_repair_own_tools
    end
    
    def set_discipline_info(discipline, item)
        craft_method,book,script,base = [:craft_prep,'','','']
        case discipline
        when 'blacksmithing', 'weaponsmithing', 'armorsmithing'
            book,script,base = ['forging', 'smith', 'ingot']
            materials_info = @crafting_data['stock'][@workorders_materials['metal_type']]
            skill,tools,@belt = ['Forging',@settings.forging_tools,@settings.forging_belt]
            craft_method = :forge_prep
        when 'tailoring'
            book,script = ['outfitting','sew']
            skill,tools,@belt,@work_room = ['Outfitting',@settings.outfitting_tools,@settings.outfitting_belt,@settings.outfitting_room]
            if item['chapter'] == 5
                base = 'yarn'
                materials_info = @crafting_data['stock'][@workorders_materials['knit_type']]
            elsif [2,3,4].include?(item['chapter'])
                base = 'cloth'
                materials_info = @crafting_data['stock'][@workorders_materials['fabric_type']]
            else
                base = 'leather'
                materials_info = @crafting_data['stock'][@workorders_materials['leather_type']]
            end
        when 'shaping'
            book,script,base = ['engineering','shape','lumber']
            materials_info = @crafting_data['stock'][@workorders_materials['wood_type']]
            skill,tools,@belt,@work_room = ['Engineering',@settings.shaping_tools,@settings.engineering_belt,@settings.engineering_room]
        when 'carving'
            book,script = ['engineering','carve']
            if @carving_type == 'bone'
                base = 'stack'
                materials_info = @crafting_data['stock'][@workorders_materials['bone_type']]
            else
                materials_info = @crafting_data['stock'][@workorders_materials['stone_type']]
                craft_method = :stone_prep
            end
            skill,tools,@belt,@work_room = ['Engineering',@settings.carving_tools,@settings.engineering_belt,@settings.engineering_room]
        when 'remedies'
            book,script,materials_info,craft_method = ['alchemy', 'slim-remedy',@crafting_data['stock'],:remedy_prep]
            skill,tools,@belt,@work_room = ['Alchemy',@settings.alchemy_tools,@settings.alchemy_belt,@settings.alchemy_room]
        when 'artificing'
            book,script,materials_info,craft_method = ['enchanting','enchant',@crafting_data['stock'],:enchant_prep]
            skill,tools,@belt,@work_room = ['Enchanting',@settings.enchanting_tools,@settings.enchanting_belt,@settings.enchanting_room]
        end

        return [craft_method,book,script,base,skill,tools,@belt,@work_room,materials_info]
    end

    def withdraw_funds(item, book, quantity, base, materials_info)
        total_cost = DRCC.crafting_cost(item, @hometown, book = 'alchemy' ? item['part']+['alcohol','water','coal'] : item['part'], quantity, (book =~ /alchemy|enchanting/i) || (book == 'forging' && @workorders_materials['custom'][base]) ? false : materials_info)
        total_cost += 5000 if @workorders_repair
        DRCM.ensure_copper_on_hand(total_cost, @settings, @hometown)
    end

################             REPAIR               ######################

    def repair_own_tools(info, tools)
        current = Room.current.id
        DRCM.ensure_copper_on_hand(1500, @settings)
        DRCT.walk_to(current)
        DRCC.repair_own_tools(get_data('crafting')['blacksmithing'][@hometown], tools, @bag, @bag_items, @belt)
    end

################           WORK SECTION            ######################

    def craft_prep(info, materials_info, item, quantity, book, script, base)
        unless @workorders_materials['custom'][base] && check_own_materials(item, quantity, @workorders_materials['custom'][base], base)
            type = materials_info['stock-name']
            base_to_buy,scrap = calc_stock(materials_info, item, quantity, base)
            buy_material_stackables(info, materials_info, quantity, base_to_buy, base) if base_to_buy
        else
            type = @workorders_materials['custom'][base]
        end

        order_parts(item['part'], quantity) if item['part']
        DRCC.find_shaping_room(@hometown, @work_room)
        quantity.times do
            if @skip_logging
                training_monitor(script, [item['chapter'], item['name'], type, item['noun']], book, item['noun'])
                break if training_done?(book, info, item['part'], base, type)
            else
                break unless check_logbook_count(book, quantity)
                DRC.wait_for_script_to_complete(script, [item['chapter'], item['name'], type, item['noun']])
                DRCC.logbook_item(book, item['noun'], @bag)
            end
        end

        if @workorders_materials['custom'][base] && DRCI.exists?("#{type} #{base}", @bag)
            deed_item("#{type} #{base}")
        else
            if scrap && !@retain_crafting_materials
                trash_crafting_item("#{materials_info['stock-name']} #{base}", info) 
            elsif scrap
                deed_item("#{type} #{base}")
            end
        end
    end

    def stone_prep(info, materials_info, item, quantity, book, script, base)
        buy_material_singles(info, materials_info, quantity)
        order_parts(item['part'], quantity) if item['part']
        DRCC.find_shaping_room(@hometown)
        quantity.times do
            break unless check_logbook_count("engineering", quantity)
            DRC.wait_for_script_to_complete('carve', [item['chapter'], item['name'], materials_info['stock-name'], item['noun']])
            DRCC.logbook_item('engineering', item['noun'], @bag)
        end
    end

    def remedy_prep(info, materials_info, item, quantity, book, script, base)
        leftovers = buy_remedies(info, materials_info, item, quantity)
        @bag_items << leftovers
        DRCT.walk_to(@work_room)
        quantity.times do
            DRC.wait_for_script_to_complete('slim-remedy', [item['name']])
            name = DRC.right_hand
            if @skip_logging
                DRCI.dispose_trash(name, @settings.worn_trashcan, @settings.worn_trashcan_verb)
                break if training_done?(book, info, leftovers, base)
            else
                break if finished_remedies(name, quantity) >= quantity*5
                DRCC.stow_crafting_item(name, @bag, nil)
            end
        end
        log_remedy(item['noun'], quantity) unless @skip_logging
        leftovers.each { |part| trash_crafting_item(part, info) }
    end

    def enchant_prep(info, materials_info, item, quantity, book, script, base)
        item['part'].each do |part|
            buy_material_singles(info, materials_info[part], quantity, part)
        end
        DRCC.fount(info['tool-room'], 1, info['fount'], quantity, @bag, @bag_items, @belt)
        DRCI.stow_hands
        # Start crafting #
        DRCC.find_enchanting_room(@hometown, @work_room)
        quantity.times do
            if @skip_logging
                DRC.wait_for_script_to_complete('enchant', [item['chapter'], item['name'], item['noun']])
                DRCI.dispose_trash(item['noun'], @settings.worn_trashcan, @settings.worn_trashcan_verb)
                break if training_done?(book, info, item['part'], base)
            else
                DRC.wait_for_script_to_complete('enchant', [item['chapter'], item['name'], item['noun']])
                DRCC.logbook_item('enchanting', item['noun'], @bag)
            end
        end
    end
    ## TODO:
    # 1. ingot calcs, minimizing waste on purchases
    # 2. bingots with above

    def forge_prep(info, materials_info, item, quantity, book, script, base)
        unless @workorders_materials['custom'][base] && check_own_ingot(item, quantity, @workorders_materials['custom'][base])
            buy_material_singles(info, materials_info, quantity)
            base,scrap = calc_stock(materials_info, item, quantity, base)
            type = materials_info['stock-name']
        else
            type = @workorders_materials['custom'][base]
        end
        quantity.times do
            if @skip_logging
                training_monitor(script, [materials_info['stock-name'], item['name']], book, item['noun'])
                break if training_done?(book, info, item['part'], base, type)
            else
                break unless check_logbook_count("forging", quantity)
                DRC.wait_for_script_to_complete('smith', [materials_info['stock-name'], item['name']])
                DRCC.logbook_item('forging', item['noun'], @bag)
            end
            if scrap
                DRCC.get_crafting_item("#{materials_info['stock-name']} #{base}", @bag, ["#{materials_info['stock-name']} #{base}"], nil)
                DRCI.dispose_trash("#{materials_info['stock-name']} #{base}", @settings.worn_trashcan, @settings.worn_trashcan_verb) 
            end
        end
        smelt(@workorders_materials['custom'][base]) if @smelt
        deed_item("#{@workorders_materials['custom'][base]} #{base}") if @workorders_materials['custom'][base]
    end

    def check_logbook_count(craft, quantity)
        /(\d)/ =~ DRC.bput("read my #{craft} logbook", /This work order appears to be complete/, /You must bundle and deliver (\d+) more/, /^This logbook is not currently tracking any work orders/)
    end

    def training_monitor(script, args, book, name)
        verify_script(script)
        start_script(script, args.map { |arg| arg.to_s =~ /\s/ ? "\"#{arg}\"" : arg })
        pause 30

        @counter ||= 0
        @counter += 30
        loop do
            if Script.running?(script) && DRSkill.getxp(book.capitalize) == 34
                DRC.message("Stopping #{script} after #{@counter/60} minutes because #{book.capitalize} is mindlocked")
                stop_script(script)
                stop_script("forge") if Script.running?("forge")
                pause 1 while Script.running?(script)
                break
            elsif Script.running?(script)
                @counter += 1
                pause 1
                next
            end
            DRCI.dispose_trash(name, @settings.worn_trashcan, @settings.worn_trashcan_verb)
            return
        end

        case book
        when /forging/
            [DRC.left_hand,DRC.right_hand].each do |tool|
                DRCC.stow_crafting_item(tool, @bag, @belt) if @settings.forging_tools.include?(tool)
            end
            return if DRCC.clean_anvil?
            return DRCI.dispose_trash(name, @settings.worn_trashcan, @settings.worn_trashcan_verb)
        when /enchanting/
            DRCC.clean_brazier?
            [DRC.left_hand,DRC.right_hand].each do |tool|
                DRCC.stow_crafting_item(tool, @bag, @belt) if @settings.enchanting_tools.include?(tool)
            end
            2.times do fput("empty feet") end
        else
            DRCC.stow_crafting_item(DRC.right_hand, @bag, @belt)
            DRCI.dispose_trash(DRC.left_hand, @settings.worn_trashcan, @settings.worn_trashcan_verb) if checkleft
        end
    end

    def training_done?(book, info, parts, base, type = '')
        @items_remaining -= 1 # reduce remaining by 1 each time we come here, reflecting a completed use of materials.
        return false unless DRSkill.getxp(book.capitalize) > 28 # not yet at our mindstate goal
        return false if @items_remaining <= 0 # met our mindstate goal, but also finished using our materials
        DRC.message("Stopping #{book.capitalize} training after #{@counter/60} minutes because #{book.capitalize} is above training threshold of 28")

        parts.each do |part| # dumping all excess parts, this covers all of enchanting/remedies
            while DRCI.get_item?(part, @bag)
                DRCI.dispose_trash(part, @settings.worn_trashcan, @settings.worn_trashcan_verb)
            end
        end
        # don't trash stock materials if doing remedies|artificing(no stock materials to trash), if we're using custom materials(we'll be deeding remainder), or if we've specifically elected to retain them.
        return true if book =~ /enchanting|alchemy/i || @workorders_materials['custom'][base] == type || @retain_crafting_materials
        while DRCI.get_item?("#{type} #{base}", @bag)
            DRCI.dispose_trash("#{type} #{base}", @settings.worn_trashcan, @settings.worn_trashcan_verb)
        end
        true
    end

################        MATERIALS HANDLING         ######################

    def buy_material_singles(info, materials_info, quantity, name = '')
        # Buy single, non-stackable materials eg rock deeds, ingots, herbs
        quantity.times do
            if materials_info['stock-number']
                DRCT.order_item(info['stock-room'], materials_info['stock-number'])
                DRCC.stow_crafting_item([DRC.left_hand,DRC.right_hand].compact.first, @bag, nil)
            else
                DRCT.buy_item(info['stock-room'], name)
                DRCC.stow_crafting_item(name, @bag, nil)
            end
        end
    end

    def buy_material_stackables(info, materials_info, quantity, base_to_buy, base)
        # Buy stackable materials eg lumber/bone stacks
        # Total volume for max count workorder needs to be under total stackable size
        base_to_buy.times do
            DRCT.order_item(info['stock-room'], materials_info['stock-number'])
            fput("combine #{base}")
        end
        DRCC.stow_crafting_item(base, @bag, nil)
    end

    def buy_remedies(info, materials_info, item, quantity)
        herb_list = ['crushed flowers','muljin','belradi','dioica','hulnik','aloe','eghmok','lujeakave','yelith','cebi','blocil','hulij','nuloe','hisan']
        item['part'].each do |part|
            if herb_list.include?(part)
                needed = part.split(' ').last
                collect_and_process(item, needed, quantity)
                item['part'].shift # Update our parts list to remove the herb we've already purchased
            else
                quantity.times { buy_material_singles(info, materials_info[part], 1, part) } # Buy one  main herb stack for each remedy to craft
            end
        end
        item['part'] += ['water', 'alcohol'] # add the bits we might need to parts array for purchase and disposal
        item['part'].each { |part| buy_material_singles(info, materials_info[part], 1, part) } # purchase one of each of these bits
        buy_material_singles(get_data('crafting')['blacksmithing'][@hometown], materials_info['coal'], 1, 'nugget') && item['part'] += ['coal nugget'] # Buy a single coal nugget, plenty, and add it to our parts list
        return item['part'] # Return a list of parts for disposal at the end.
    end

    def finished_remedies(name, quantity)
        type,base = name.split(' ')
        while DRCI.get_item?("#{type} #{base}", @bag)
            fput("combine")
        end
        return material_volume(type, base)
    end

    def calc_stock(materials_info, recipe, quantity, base = '')
        total_needed = quantity*recipe['volume']
        if base == 'ingot'
            scrap = (recipe['volume'])%materials_info['stock-volume'] > 0 ? true : false # if any left after division (%) we'll have to toss the extra bits between crafts
            return [base, scrap] # These are not stackable, so we just need to determine if there will be leftovers out of each ingot
        elsif on_hand_stock = check_own_materials(recipe, quantity, materials_info['stock-name'], base) # If we have enough materials, returns a value for on_hand_stock. otherwise returns false.
            scrap = total_needed == on_hand_stock ? false : true
            return [false,scrap] # have what we need, no need to buy
        elsif DRCI.get_item?("#{materials_info['stock-name']} #{base}", @bag)
            /(\d+)/ =~ DRC.bput("count my #{materials_info['stock-name']} #{base}", /^You count out (\d+) (pieces|yards) of (lumber|material)/)
            on_hand_stock = Regexp.last_match(1).to_i
            if on_hand_stock >= (total_needed) # We have what we need, so no need to buy more.
                DRCC.stow_crafting_item("#{materials_info['stock-name']} #{base}", @bag, @belt)
                scrap = (total_needed)%materials_info['stock-volume'] > 0 ? true : false
                return [base,scrap]
            end
            total_needed -= on_hand_stock # How many do we need to buy to add to what we already have.
        end
        
        base_to_buy = (total_needed/materials_info['stock-volume'].to_f).ceil
        scrap = (total_needed)%materials_info['stock-volume'] > 0 ? true : false

        [base_to_buy, scrap]
    end

################          PARTS HANDLING           ######################

    def buy_parts(parts, partroom)
        parts.each do |part|
            DRCT.buy_item(partroom, part)
            DRCC.stow_crafting_item(part, @bag, @belt)
        end
    end

    def order_parts(parts, quantity)
        parts.each do |part|
            data = @recipe_parts[part][@hometown]
            quantity.times do
                if data['part-number']
                    DRCT.order_item(data['part-room'], data['part-number'])
                else
                    DRCT.buy_item(data['part-room'], part)
                end
                DRCC.stow_crafting_item(part, @bag, @belt)
            end
        end
    end
    
    def trash_crafting_item(trash, info)
        DRCC.get_crafting_item(trash, @bag, @bag_items, @belt)
        DRCI.dispose_trash(trash, @settings.worn_trashcan, @settings.worn_trashcan_verb)
    end

################    PERSONAL MATERIALS HANDLING    ######################

    def collect_and_process(recipe, herb_needed, quantity) # can require significant outdoorsmanship skill and somewhat careful selection of an outdoors room. Alternative is just foraging and processing your own.
        unless @workorders_collect_herbs
            quantity.times { DRCC.stow_crafting_item(DRC.left_hand, @bag, nil) if redeem_deed(herb_needed) }
            return
        end
        forage_name = ['muljin sap','belradi moss','dioica sap','hulnik grass','aloe leaves','eghmok moss','lujeakave root','yelith root','cebi root','blocil berries','hulij leaves','nuloe stem','hisan flower']
        herb = forage_name.find { |h| h.include?(herb_needed) } || 'blue flower' # crushed flowers is the special case here, so unless we find a match, it defaults to blue flowers.
        DRCT.walk_to(@settings.outdoors_room)
        flowers,needed = [0,quantity] # number of individual flower stacks, representing 1 does, and 25 count stacks, representing 5 doses
        until flowers >= 5*quantity
            case DRC.bput("collect #{herb}", /^You manage to collect/, /^You.*(forage|wander) around/, /^You find something dead/, /too cluttered/)
            when /You.*(forage|wander) around/, /You find something dead/
                DRC.message("Failed to collect #{herb}. Either it cannot be found here or you don't have the skill to collect it.\nYou will have to collect your own herbs for this recipe going forwards.\nChange yaml setting: workorders_collect_herbs to false.")
                exit
            when /too cluttered/
                fput("dump junk")
                pause 60
                redo
            end
            until /(There doesn't seem to be anything left in the pile|You pick up)/ =~ DRC.bput("get #{herb}", /^You get.*a pile on the ground/, /^You pick up/, /^There doesn't seem to be anything left in the pile/) 
                DRCC.stow_crafting_item(herb, @bag, @belt)
                flowers += 1
            end
            if checkright
                DRCC.stow_crafting_item(herb, @bag, @belt)
                flowers += 1
            end
        end
        DRCT.walk_to(get_data('crafting')['remedies'][@hometown]['press-grinder-rooms'].first)
        process = recipe['container'] == 'bowl' ? "put my #{herb} in grinder" : "put my #{herb} in press"
        quantity.times do
            5.times do
                DRCI.get_item?(herb, @bag)
                DRC.bput(process, /^You place some/)
                DRC.bput("combine", /^You must be holding/, /^You combine/)
                flowers -= 1
            end
            DRCC.stow_crafting_item(DRC.left_hand, @bag, nil)
            needed -= 1
        end
        until /referring/ =~ DRC.bput("get my #{herb}", /^You get/, /^You are already/, /^You're already/, /What were you referring to/)
            DRCI.dispose_trash(herb, @settings.worn_trashcan, @settings.worn_trashcan_verb)
        end
    end

    def redeem_deed(deed_type, base = '')
        if DRCI.get_item?("#{@ordinals.first} #{deed_type}", @workorders_deed_storage)
            case DRC.bput("tap my deed", /^An attendant arrives/, /^The worker explains/, /^The deed appears to be redeemable only in one of the Crafting Society Halls/)
            when /explains/
                DRCC.stow_crafting_item('deed', @workorders_deed_storage, nil)
                @ordinals.shift
                return redeem_deed(deed_type, base)
            when /The deed appears to be redeemable only in one of the Crafting Society Halls/
                DRCC.stow_crafting_item('deed', @workorders_deed_storage, nil)
                DRCT.walk_to(@crafting_data['blacksmithing'][@hometown]['stock-room'])
                return redeem_deed(deed_type, base)
            end
            pause 0.5
            DRCI.lift_specific?("#{deed_type} #{base}")
            true
        else
            DRC.message("Missing the required deeds for #{deed_type}")
            false
        end
    end

    def deed_item(item)
        if /I could not find/ =~ DRC.bput('look my deed packet', /You count \d+ deed claim forms remaining/, /I could not find what you were referring to/)
            DRCM.ensure_copper_on_hand(@cash_on_hand || 10_000, @settings)
            DRCT.order_item(@deeds_room, @deeds_number)
        end
        DRCI.get_item?("deed packet")
        DRCI.get_item_if_not_held?(item, @bag)
        DRC.bput("push my #{item} with packet", /^You push/)
        DRCC.stow_crafting_item("packet", @bag, nil)
        DRCC.stow_crafting_item("deed", @workorders_deed_storage, nil)
    end

    def ingot_volume(material)
        DRC.bput("analyze my #{material} ingot", /About \d+ volume/).scan(/\d+/).first.to_i
    end

    def material_volume(type, base)
        DRC.bput("count my #{type} #{base}", /^You count out (\d+) (pieces|uses|yards).*(lumber|remaining|material)/).scan(/\d+/).first.to_i
    end

    def deed_volume(material)
        DRC.bput("read my #{material} deed", /Volume:\s*\d+/, /Amount:\s*\d+/, /Pieces:\s*\d+/).scan(/\d+/).first.to_i
    end

    def check_own_materials(item, quantity, type, base)
        volume = 0
        while volume < (item['volume'] * quantity)
            if DRCI.get_item?("#{type} #{base}", @bag)
                fput('combine')
                volume = material_volume(type, base)
                next
            end
            if volume < (item['volume'] * quantity)
                if redeem_deed(type, base)
                    if [DRC.right_hand,DRC.left_hand].compact.size > 1
                        fput("combine")
                    end
                    volume = material_volume(type, base)
                else
                    DRC.message("Out of #{base} and deeds")
                    [DRC.right_hand,DRC.left_hand].each { |item| item =~ /deed/i ? DRCC.stow_crafting_item("deed", @workorders_deed_storage, nil) : DRCC.stow_crafting_item(item, @bag, @belt)}
                    return false
                end
            end
        end
        return volume
    end

    def check_own_ingot(item, quantity, type)
        if DRCI.get_item?("#{type} ingot", @bag)
            if volume = deed_volume(type)                
                redeem_deed(type, 'ingot')
            else
                echo('out of material/deeds')
                return false
            end
        end

        volume ||= ingot_volume(type)

        DRCI.stow_hands
        @smelt = false

        if volume < quantity * item['volume']
            @smelt = true
            if volume = deed_volume(type)
                redeem_deed(type, 'ingot')
            else
                echo('out of material/deeds')
                return false
            end
        end

        DRCI.stow_hands

        if volume < quantity * item['volume']
            echo('out of material/deeds')
            smelt(type)
            return check_own_ingot(item, quantity, type)
        end

        true
    end

    def smelt(type)
        DRCC.find_empty_crucible(@hometown)
        2.times do
            return unless DRCI.get_item?("#{type} ingot", @bag)
            DRCI.put_away_item_unsafe("#{type} ingot", "crucible")
        end
        DRC.wait_for_script_to_complete('smelt')
        DRCI.stow_hands
    end

################       TASK MASTER HANDLING        ######################

    def request_work_order(recipes, npc_rooms, npc, npc_last_name, discipline, logbook, diff)
        match_names = recipes.map { |x| x['name'] }
        diff ||= 'challenging'
        DRCI.stow_hands
        500.times do
            find_npc(npc_rooms, npc_last_name)
            DRCC.get_crafting_item("#{logbook} logbook", @bag, @bag_items, @belt)
            case DRC.bput("ask #{npc} for #{diff} #{discipline} work", '^To whom', 'order for .* I need \d+ ', 'order for .* I need \d+ stacks \(5 uses each\) of .* quality', 'You realize you have items bundled with the logbook', 'You want to ask about shadowlings')
            when 'You want to ask about shadowlings'
                pause 10
                fput('say Hmm.')
            when /order for (.*)\. I need (\d+) /
                item = Regexp.last_match(1)
                quantity = Regexp.last_match(2).to_i
                if @min_items <= quantity && quantity <= @max_items && match_names.include?(item)
                    DRCC.stow_crafting_item("#{logbook} logbook", @bag, @belt)
                    return [item, quantity]
                end
            when /order for (.*)\. I need (\d+) stacks \(5 uses each\) of .* quality/
                item = Regexp.last_match(1)
                quantity = Regexp.last_match(2).to_i
                if @min_items <= quantity && quantity <= @max_items && match_names.include?(item)
                    DRCC.stow_crafting_item("#{logbook} logbook", @bag, @belt)
                    return [item, quantity]
                end
            when 'You realize you have items bundled with the logbook'
                DRC.bput('untie my logbook', 'You untie')
                trash = [DRC.left_hand,DRC.right_hand].find { |thing| thing !~ /logbook/i }
                DRCI.dispose_trash(thing, @settings.worn_trashcan, @settings.worn_trashcan_verb)
            end
        end
        DRCC.stow_crafting_item('logbook', @bag, @belt)
        DRC.message("Failed to find a qualifying order based on your current settings.")
        exit
    end    

    def log_remedy(name, quantity)
        return unless name
        quantity.times do
            if /You trace an X/ =~ DRC.bput("mark my #{name} at 5", /^You measure out/, /^There is not enough/, /^You must be holding/, /^You trace an X across your chest/) # if we have exactly the number required, the last remedy won't mark
                DRC.message("Missing the finished product for some reason, aborting log routine")
                return
            end
            DRC.bput("break my #{name}", /^You carefully break off/, /^You can't break that/) # and won't break. Bundles fine.
            DRCC.stow_crafting_item(name, @bag, @belt)
        end
        mod = ''
        if checkleft
            mod = 'second '
            DRCC.stow_crafting_item(name, @bag, @belt)
        end
        DRCC.get_crafting_item("alchemy logbook", @bag, @bag_items, @belt)
        quantity.times do
            DRCC.get_crafting_item("#{mod}#{name}", @bag, @bag_items, @belt)
            unless /You notate the/ =~ DRC.bput("bundle my #{name} with my logbook", /^You notate the/, /^The workorder requires/)
                DRCI.dispose_trash(name, @settings.worn_trashcan, @settings.worn_trashcan_verb)
            end
        end
        DRC.bput("put my alchemy logbook in my #{@bag}", 'You put', 'What were you referring to')
    end

    def complete_work_order(info)
        DRCI.stow_hands
        loop do
            find_npc(info['npc-rooms'], info['npc_last_name'])
            DRCC.get_crafting_item("#{info['logbook']} logbook", @bag, @bag_items, @belt)
            DRC.release_invisibility
            case DRC.bput("give my #{info['logbook']} logbook to #{info['npc']}", /You hand/, /You can/, /What were you/, /Apparently the work order time limit has expired/, /The work order isn\'t yet complete/, /What is it you\'re trying to give/)
            when /You can/, /What were you/, /What is it/
                next
            end
            break
        end
        DRCC.stow_crafting_item("#{info['logbook']} logbook", @bag, @belt)
    end

    def find_npc(room_list, npc)
        room_list.each do |room_id|
            break if DRRoom.npcs.include?(npc)
            DRCT.walk_to(room_id)
        end
    end
end

before_dying do
    Flags.delete('proper-repair')
end

WorkOrders.new
