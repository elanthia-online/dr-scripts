=begin
  Documentation: https://elanthipedia.play.net/Lich_script_repository#train
=end

custom_require.call(%w[common common-money common-travel drinfomon])

class CrossingTrain
  include DRC
  include DRCM
  include DRCT

  def initialize
    setup

    bput('tdp', 'You have \d+')

    arg_definitions = [
      [
        { name: 'strength', regex: /^str.*\d*/i, optional: true, description: 'Number of times to train Strength (e.g str3 or str)' },
        { name: 'stamina', regex: /^sta.*\d*/i, optional: true, description: 'Number of times to train Stamina (e.g sta3 or sta)' },
        { name: 'reflex', regex: /^r.*\d*/i, optional: true, description: 'Number of times to train Reflex (e.g r3 or r)' },
        { name: 'agility', regex: /^a.*\d*/i, optional: true, description: 'Number of times to train Agility (e.g a3 or a)' },
        { name: 'discipline', regex: /^d.*\d*/i, optional: true, description: 'Number of times to train Discipline (e.g d3 or d)' },
        { name: 'wisdom', regex: /^w.*\d*/i, optional: true, description: 'Number of times to train Wisdom (e.g w3 or w)' },
        { name: 'intelligence', regex: /^i.*\d*/i, optional: true, description: 'Number of times to train Intelligence (e.g i3 or i)' },
        { name: 'charisma', regex: /^c.*\d*/i, optional: true, description: 'Number of times to train Charisma (e.g c3 or c)' }
      ]
    ]

    args = parse_args(arg_definitions)

    if args.to_h.empty?
      display_args(arg_definitions)
      return
    end

    echo args.to_s

    @copper = 0

    to_train = [args.strength, args.stamina, args.reflex, args.agility, args.discipline, args.wisdom, args.intelligence, args.charisma].join(' ').gsub(/([A-z]+)(\d+)/, '\1 \2')

    to_train = find_train(to_train)

    return unless can_train?(to_train)

    return unless withdraw_exact_amount?("#{@copper} copper", @hometown)
    
    to_train.each { |attribute, count| train(@attributes[attribute], count) }
    pause
    fput 'info' # Update drinfomon state
  end

  def determine_cost(tdps, high_skill = false)
    @copper += tdps * (high_skill ? 15 : 2)
  end

  def can_train?(to_train)
    tdp_cost = 0
    to_train.each do |attribute, count|
      target = @attributes[attribute]['current'] + count
      project_result = bput("tdp project #{attribute} #{target}", 'It will cost you .* TDPs to reach', 'Please specify a goal that is HIGHER')
      if project_result == 'Please specify a goal that is HIGHER'
        echo "*** ERROR CALCULATING TDP COST FOR '#{attribute} #{target}'***"
        return false
      end
      temp = project_result.match(/It will cost you (.*) TDPs to reach/).to_a[1].to_i
      determine_cost(temp, target >= 101)
      tdp_cost += temp
    end

    @tdp_total = tdp_cost

    DRStats.tdps >= tdp_cost
  end

  def train(info, count)
    walk_to info['outer_room']
    fput "go #{info['inner_room']}" unless info['inner_room'].empty?
    target = info['current'] + count
    fput "train #{target}"
    fput "train #{target}"
    fput 'out'
  end

  def find_train(args)
    return [] unless args

    args
      .split(' ')
      .map(&:downcase)
      .each_with_object([]) { |item, acc| acc << (item.to_i > 0 ? [acc.last] * (item.to_i - 1) : item) }
      .flatten
      .map { |i| determine_matches(i) }
      .flatten
      .each_with_object(Hash.new(0)) { |name, counts| counts[name] += 1 }
  end

  def determine_matches(input)
    matches = @attributes.keys.select { |a| a =~ /^#{input}/ }

    return matches if matches.length == 1

    echo "Unable to match '#{input}' to a single attribute (candidates are #{matches})"
    exit
  end

  def setup
    @hometown = get_settings.hometown
    strength_out = get_data('town')[@hometown]['strength']['outer_room']
    strength_in = get_data('town')[@hometown]['strength']['inner_room']
    agility_out = get_data('town')[@hometown]['agility']['outer_room']
    agility_in = get_data('town')[@hometown]['agility']['inner_room']
    int_out = get_data('town')[@hometown]['intelligence']['outer_room']
    int_in = get_data('town')[@hometown]['intelligence']['inner_room']
    disc_out = get_data('town')[@hometown]['discipline']['outer_room']
    disc_in = get_data('town')[@hometown]['discipline']['inner_room']
    reflex_out = get_data('town')[@hometown]['reflex']['outer_room']
    reflex_in = get_data('town')[@hometown]['reflex']['inner_room']
    charisma_out = get_data('town')[@hometown]['charisma']['outer_room']
    charisma_in = get_data('town')[@hometown]['charisma']['inner_room']
    wisdom_out = get_data('town')[@hometown]['wisdom']['outer_room']
    wisdom_in = get_data('town')[@hometown]['wisdom']['inner_room']
    stamina_out = get_data('town')[@hometown]['stamina']['outer_room']
    stamina_in = get_data('town')[@hometown]['stamina']['inner_room']
    @attributes = { 'strength' => { 'outer_room' => strength_out, 'inner_room' => strength_in, 'current' => DRStats.strength },
                    'agility' => { 'outer_room' => agility_out, 'inner_room' => agility_in, 'current' => DRStats.agility },
                    'discipline' => { 'outer_room' => disc_out, 'inner_room' => disc_in, 'current' => DRStats.discipline },
                    'intelligence' => { 'outer_room' => int_out, 'inner_room' => int_in, 'current' => DRStats.intelligence },
                    'reflex' => { 'outer_room' => reflex_out, 'inner_room' => reflex_in, 'current' => DRStats.reflex },
                    'charisma' => { 'outer_room' => charisma_out, 'inner_room' => charisma_in, 'current' => DRStats.charisma },
                    'wisdom' => { 'outer_room' => wisdom_out, 'inner_room' => wisdom_in, 'current' => DRStats.wisdom },
                    'stamina' => { 'outer_room' => stamina_out, 'inner_room' => stamina_in, 'current' => DRStats.stamina } }
  end
end

# Call this last to avoid the need for forward declarations
CrossingTrain.new
