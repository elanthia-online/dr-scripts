=begin
Empathy training via Embrace of the Vela'Tohr (EV) plant healing.

Cycles: stow hands -> (optional ADC pre-cast) -> walk to plant room -> ensure EV ->
touch plant N times -> walk to healing room -> healme -> (optional community EV cast) ->
check empathy threshold -> repeat.

YAML Settings (nested under plantheal_settings):

  plantheal_settings:
    touch_count: 3              # times to touch plant per cycle
    plant_room: null            # room with the plant (default: hometown NPC empath)
    healing_room: null          # room to heal in (default: safe_room)
    prep_room: null             # room to prep EV if different from plant_room
    cast_room: null             # room to cast a community EV on exit
    empathy_threshold: 24       # stop when Empathy mindstate >= this
    heal_past_ml: false         # if true, keep cycling past threshold
    use_adc: false              # pre-cast plant_heal waggle_set (Heal, BS, etc.)
    ev_cast_mana: 600           # mana for community EV in cast_room
    ev_extra_wait: 15           # extra seconds after RT before casting EV
    focus_container: null       # container to get/stow focus from (e.g. "backpack")

  Required waggle_sets:
    plantheal: Must contain an "Embrace of the Vela'Tohr" spell entry. All spell data
        (mana, focus, worn/tied/sheathed focus) is drawn from this entry. If no prep_room
        is set, EV casting is delegated to buff. If prep_room is set, EV is cast manually
        (buff can't switch rooms). Spell data not defined here is filled by dependency
        from base-spells.yaml.

  Required waggle_sets (if use_adc is true):
    plant_heal: waggle_set for pre-casting healing spells (Heal, Blood Staunching, etc.)

  Legacy flat settings are still supported with a deprecation warning:
    plant_total_touch_count -> touch_count
    plant_custom_room       -> plant_room
    plant_drop_room         -> plant_room
    plant_healing_room      -> healing_room
    plant_prep_room         -> prep_room
    plant_heal_past_ML      -> heal_past_ml
    plant_adc               -> use_adc
    plant_empathy_threshold -> empathy_threshold
    cast_room               -> cast_room
    ritual_ev_mana          -> ev_cast_mana
    ritual_ev_extra_wait    -> ev_extra_wait
    ritual_focus_container   -> focus_container
=end

class PlantHeal
  unless DRStats.empath?
    DRC.message('*** Must be an Empath with the Embrace of the Vela\'Tohr spell to run this! ***')
    exit
  end

  PLANT_NOUNS = /vela'tohr (plant|thicket|bush|briar|shrub|thornbush)/i
  NO_HEAL_NEEDED = [
    'has no need of healing.'
  ]
  TOUCH_RESPONSES = [
    'Roundtime',
    *NO_HEAL_NEEDED,
    'you have no empathic bond',
    'Touch what?'
  ]

  def initialize
    settings = get_settings
    ps = load_settings(settings)

    # Resolve rooms
    town_data = get_data('town')
    ht_name = settings.force_healer_town || settings.hometown
    hometown = town_data[ht_name]

    @touch_count    = ps[:touch_count]
    @heal_past_ml   = ps[:heal_past_ml]
    @threshold      = ps[:empathy_threshold]
    @use_adc        = ps[:use_adc]
    @ev_cast_mana   = ps[:ev_cast_mana]
    @ev_extra_wait  = ps[:ev_extra_wait]

    @plantroom = ps[:plant_room].to_i.nonzero? ||
                 (hometown && hometown['npc_empath'] && hometown['npc_empath']['id'].to_i) ||
                 (DRC.message("*** Can't resolve plant room. Set plantheal_settings.plant_room."); exit)

    @healingroom = ps[:healing_room].to_i.nonzero? || settings.safe_room.to_i
    @preproom    = ps[:prep_room].to_i    # 0 means same as plantroom
    @castroom    = ps[:cast_room].to_i    # 0 means skip cast-for-others

    # Waggle set references
    waggle = settings.waggle_sets || {}
    @ev_waggle = waggle['plantheal']
    @plant_heal_waggle = waggle['plant_heal']

    # Validate required plantheal waggle_set
    validate_ev_waggle!

    # Resolve focus config from plantheal waggle_set
    resolve_focus_config(ps)

    # Validation
    if @use_adc && @plant_heal_waggle.nil?
      DRC.message("*** use_adc is true but waggle_set 'plant_heal' is not defined!")
      exit
    end

    # If prep_room is set, we MUST cast EV manually (buff can't switch rooms).
    # Otherwise delegate to buff via the plantheal waggle_set.
    @manual_ev = @preproom.nonzero?

    Flags.add('plantheal-heal-expire', 'You feel the warmth in your flesh gradually subside.')

    DRCI.stow_hands
    run_loop
  end

  # ---------------------------------------------------------------------------
  # Settings loading with legacy migration
  # ---------------------------------------------------------------------------

  def load_settings(settings)
    ps = (settings.plantheal_settings || {}).dup

    # Migrate legacy flat settings into the hash, warning if found
    migrate = {
      'plant_total_touch_count' => 'touch_count',
      'plant_custom_room'       => 'plant_room',
      'plant_drop_room'         => 'plant_room',
      'plant_healing_room'      => 'healing_room',
      'plant_prep_room'         => 'prep_room',
      'plant_heal_past_ML'      => 'heal_past_ml',
      'plant_adc'               => 'use_adc',
      'plant_empathy_threshold' => 'empathy_threshold',
      'cast_room'               => 'cast_room',
      'ritual_ev_mana'          => 'ev_cast_mana',
      'ritual_ev_extra_wait'    => 'ev_extra_wait',
      'ritual_focus_container'  => 'focus_container',
    }

    migrate.each do |old_key, new_key|
      old_val = safe_setting(settings, old_key)
      next if old_val.nil?
      unless ps.key?(new_key)
        DRC.message("*** Deprecated setting '#{old_key}' -- migrate to plantheal_settings.#{new_key}")
        ps[new_key] = old_val
      end
    end

    # Apply defaults and type coercion
    {
      touch_count: (ps['touch_count'].to_i.nonzero? || 3),
      plant_room: ps['plant_room'].to_i,
      healing_room: ps['healing_room'].to_i,
      prep_room: ps['prep_room'].to_i,
      cast_room: ps['cast_room'].to_i,
      empathy_threshold: (ps['empathy_threshold'].to_i.nonzero? || 24),
      heal_past_ml: to_bool(ps['heal_past_ml'], false),
      use_adc: to_bool(ps['use_adc'], false),
      ev_cast_mana: (ps['ev_cast_mana'].to_i.nonzero? || 600),
      ev_extra_wait: (ps['ev_extra_wait'].to_i.nonzero? || 15),
      focus_container: ps['focus_container'].to_s.strip,
    }
  end

  EV_SPELL_KEY = "Embrace of the Vela'Tohr"

  # Validate that the plantheal waggle_set exists and contains an
  # "Embrace of the Vela'Tohr" spell entry. Mana and other spell data
  # are filled by dependency from base-spells.yaml, so only the key is required.
  def validate_ev_waggle!
    unless @ev_waggle
      DRC.message("*** waggle_set 'plantheal' is required! Define a 'plantheal' waggle_set with an '#{EV_SPELL_KEY}' entry.")
      exit
    end

    unless @ev_waggle.key?(EV_SPELL_KEY)
      DRC.message("*** waggle_set 'plantheal' must contain an '#{EV_SPELL_KEY}' spell entry!")
      DRC.message("*** Found keys: #{@ev_waggle.keys.join(', ')}")
      exit
    end
  end

  # Resolve focus configuration from the ev waggle_set.
  # All spell data (focus, worn_focus, tied_focus, sheathed_focus) comes from the
  # waggle_set. The only user-configurable override is focus_container (no waggle_set
  # equivalent -- used for "get from"/"stow in" when focus is in a specific container).
  def resolve_focus_config(ps)
    ev_spell = ev_spell_data

    @focus_item      = ev_spell['focus'].to_s.strip
    @focus_worn      = ev_spell['worn_focus'] || false
    @focus_tied      = ev_spell['tied_focus'].to_s.strip
    @focus_sheathed  = ev_spell['sheathed_focus'] || false
    @focus_container = ps[:focus_container].to_s.strip
    @focus_invoke    = @focus_item.empty? ? '' : "invoke my #{@focus_item}"
  end

  # Extract the EV spell data hash from the plantheal waggle_set.
  def ev_spell_data
    return nil unless @ev_waggle

    @ev_waggle[EV_SPELL_KEY]
  end

  def safe_setting(settings, key)
    settings.respond_to?(key) ? settings.send(key) : nil
  rescue
    nil
  end

  def to_bool(val, default)
    return default if val.nil?
    %w[true 1 yes y].include?(val.to_s.strip.downcase)
  end

  # ---------------------------------------------------------------------------
  # Main loop
  # ---------------------------------------------------------------------------

  def run_loop
    loop do
      mindstate_check

      # Pre-cast healing spells via ADC if enabled
      if @use_adc
        DRC.wait_for_script_to_complete('buff', ['plant_heal'])
      end

      # Walk to plant room
      DRCT.walk_to(@plantroom)

      # Ensure EV is active
      ensure_ev

      # Touch the plant
      touch_plant

      # Re-check empathy before healing (may have crossed threshold during touching)
      mindstate_check

      # Return to heal
      DRCT.walk_to(@healingroom)
      DRC.wait_for_script_to_complete('healme')

      # Optional: cast community EV
      cast_for_others if @castroom.nonzero?
    end
  end

  # ---------------------------------------------------------------------------
  # EV management
  # ---------------------------------------------------------------------------

  def ensure_ev
    return if DRSpells.active_spells.include?(EV_SPELL_KEY)

    if @manual_ev
      cast_ev_manual(ev_spell_data['mana'].to_i)
    else
      # Delegate to buff script (no room switching needed)
      DRC.wait_for_script_to_complete('buff', ['plantheal'])
    end
  end

  # Recast EV if it's below the recast threshold defined in the waggle_set.
  def recast_ev_if_needed
    ev_spell = ev_spell_data
    recast = ev_spell['recast'].to_i
    remaining = DRSpells.active_spells[EV_SPELL_KEY].to_i
    return if remaining > recast

    if @manual_ev
      cast_ev_manual(ev_spell['mana'].to_i)
    else
      DRC.wait_for_script_to_complete('buff', ['plantheal'])
    end
  end

  def cast_ev_manual(mana)
    # If we have a separate prep room, go there first
    origin = nil
    if @preproom.nonzero?
      origin = @plantroom
      DRCT.walk_to(@preproom)
    end

    get_focus
    DRCA.prepare?('EV', mana)
    invoke_focus
    waitrt?
    sleep @ev_extra_wait
    stow_focus

    # If we prepped elsewhere, walk back to cast
    DRCT.walk_to(origin) if origin

    DRC.bput('cast',
             'You gesture',
             'You strain, but are too mentally fatigued',
             'You aren\'t harnessing any mana',
             'You lose your concentration',
             'Roundtime')
    pause 3
  end

  def cast_for_others
    return unless @castroom.nonzero?

    DRCT.walk_to(@castroom)
    cast_ev_manual(@ev_cast_mana)
    DRC.message("Cast community EV in cast_room, exiting.")
    exit
  end

  # ---------------------------------------------------------------------------
  # Focus handling (only used for manual EV casting)
  # Delegates to DRCA.find_focus/stow_focus which support worn, tied, sheathed,
  # and stowed focus items.
  # ---------------------------------------------------------------------------

  def get_focus
    return if @focus_item.empty?

    # DRCA.find_focus uses container as the tied-to target when tied is set.
    # For plain stowed items (not worn/tied/sheathed), it does "get my <item>".
    # We pass the container-based "get from" as a fallback for non-worn/tied/sheathed.
    if @focus_worn || !@focus_tied.empty? || @focus_sheathed
      DRCA.find_focus(@focus_item, @focus_worn, @focus_tied.empty? ? nil : @focus_tied, @focus_sheathed)
    elsif !@focus_container.empty?
      DRC.bput("get #{@focus_item} from #{@focus_container}",
               'You get', 'You are already holding', 'What were you referring')
    else
      DRCA.find_focus(@focus_item, false, nil, false)
    end
  end

  def invoke_focus
    return if @focus_item.empty? || @focus_invoke.empty?

    result = DRC.bput(@focus_invoke,
                      'Roundtime', 'You focus your will', 'You begin attuning',
                      'is already prepared', 'need a ritual focus',
                      'You must be holding', 'You are not holding', 'Invoke what?')
    if result =~ /need a ritual focus|must be holding|are not holding|Invoke what\?/i
      get_focus
      DRC.bput(@focus_invoke,
               'Roundtime', 'You focus your will', 'You begin attuning', 'is already prepared')
    end
  end

  def stow_focus
    return if @focus_item.empty?

    if @focus_worn || !@focus_tied.empty? || @focus_sheathed
      DRCA.stow_focus(@focus_item, @focus_worn, @focus_tied.empty? ? nil : @focus_tied, @focus_sheathed)
    elsif !@focus_container.empty?
      fput("stow #{@focus_item} in #{@focus_container}")
    else
      DRCA.stow_focus(@focus_item, false, nil, false)
    end
  end

  # ---------------------------------------------------------------------------
  # Plant interaction
  # ---------------------------------------------------------------------------

  def plant_noun_in_room
    obj = DRRoom.room_objs.grep(PLANT_NOUNS).first
    return nil unless obj

    m = obj.match(/vela'tohr (\w+)/i)
    m && m[1].downcase
  end

  def touch_plant
    Flags.reset('plantheal-heal-expire')
    noun = plant_noun_in_room

    unless noun
      DRC.message("*** No plant found in room! Re-casting EV.")
      release_and_recast_ev
      noun = plant_noun_in_room
      unless noun
        DRC.message("*** Still no plant. Skipping to heal phase.")
        return
      end
    end

    touches = 0

    # Phase 1: If ADC is active and Heal is running, touch until Heal expires
    # (capped by touch_count so total touches never exceed the configured limit)
    if @use_adc && DRSpells.active_spells.include?('Heal')
      touches = touch_until_heal_expires(noun, @touch_count)
    end

    # Phase 2: Remaining count-based touches
    remaining = @touch_count - touches
    touch_by_count(noun, remaining) if remaining > 0
  end

  def touch_until_heal_expires(noun, max_touches)
    touches = 0
    until Flags['plantheal-heal-expire'] || touches >= max_touches
      result = DRC.bput("touch #{noun}", *TOUCH_RESPONSES)
      case result
      when *NO_HEAL_NEEDED
        DRC.message("Plant fully healed (during Heal phase).")
        return touches
      when 'you have no empathic bond'
        release_and_recast_ev
      when 'Touch what?'
        recast_ev_if_needed
        return touches unless plant_noun_in_room
      when 'Roundtime'
        touches += 1
        break if Flags['plantheal-heal-expire'] || touches >= max_touches
        waitfor('A nearly painful prickling sensation surges through you.',
                'You feel a surge of life energy as your regeneration')
      end
    end
    touches
  end

  def touch_by_count(noun, count = @touch_count)
    touches = 0
    while touches < count
      result = DRC.bput("touch #{noun}", *TOUCH_RESPONSES)
      case result
      when *NO_HEAL_NEEDED
        DRC.message("Plant fully healed.")
        return
      when 'you have no empathic bond'
        release_and_recast_ev
      when 'Touch what?'
        recast_ev_if_needed
        return unless plant_noun_in_room
      when 'Roundtime'
        touches += 1
      end
    end
  end

  def release_and_recast_ev
    fput('release ev')
    ensure_ev
  end

  # ---------------------------------------------------------------------------
  # Mindstate check
  # ---------------------------------------------------------------------------

  def mindstate_check
    return if @heal_past_ml

    if DRSkill.getxp('Empathy') >= @threshold
      DRC.message("Empathy mindstate at target (#{@threshold}), exiting.")
      exit
    end
  end
end

before_dying do
  Flags.delete('plantheal-heal-expire')
end

PlantHeal.new
