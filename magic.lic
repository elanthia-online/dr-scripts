custom_require.call(%w(common common-travel common-arcana))

class Magic
  
  include DRC
  include DRCA
  include DRCT
  
  def initialize
    @settings = get_settings
    skill = variable[1]
	echo skill
	
    count = 0
    #Loop 10 times
	(0..10).each do |i|  
	  echo i
	  train_magic(skill)
	  # Failsafe to make sure we exit
	  if count > 10
	    break
	  end
    end
  end
  
  def train_magic(skill)
    if @settings.train_with_spells
      return if mana < 40
      if @use_research && @settings.research_skills.include?(skill)
        do_research(skill)
      else
        handle_cyclic_timers(skill)
        cast_spell(@settings.training_spells[skill], skill)
      end
    else
      cast_nonspell(skill)
    end
  end
  
  def cast_nonspell(skill)
    ability = @settings.training_nonspells[skill]
    echo("using ability: #{ability}") if UserVars.crossing_trainer_debug
    if ability.include?('Khri')
      activate_khri?(@settings.kneel_khri, ability)
    else
      fput ability
    end
  end
  
  def handle_cyclic_timers(skill)
    return unless @settings.training_spells[skill]['cyclic']

    other_cyclics = @settings.training_spells.keys.select { |x| x != skill && @settings.training_spells[x]['cyclic'] }
    other_cyclics.each { |type| update_timer(type) }
    (other_cyclics + [skill]).each { |type| @settings.exp_timers[type] = 300 } # Only needs to be done once in setup, but meh.
  end
  
  def cast_spell(data, skill)
    #check_discern(data)
    if data['abbrev'] =~ /^comp/i
      walk_to @settings.compost_room
      return unless DRRoom.npcs.empty?
      fput(['\'Had this been a real compost your belongings would be gone. Composting soon', '\'Compost', '\'Compost incoming', '\'This is a code green, compost alert', '\'Pick up your valuables, compost time', '\'If it\'s on the ground it\'s gone, Compost incoming'].sample)
    end

    if (data['abbrev'] =~ /locat/i) && !DRSpells.active_spells['Clear Vision']
      fput('prep cv')
      pause 5
      cast?
    end

    if data['moon']
      # Look for a moon that will be up for the next few minutes
      unless Script.running? 'moonwatch'
        echo 'moonwatch is not running. Starting it now'
        UserVars.moons = {}
        custom_require.call('moonwatch')
        echo "Run `;e autostart('moonwatch')` to avoid this in the future"
        pause 0.5 while UserVars.moons.empty?
      end
      unless moon = UserVars.moons.find { |moon_name, moon_data| UserVars.moons['visible'].include?(moon_name) && moon_data['timer'] >= 4 }.first
        echo "No moon available to cast #{data['abbrev']}"

        weather = bput('weather', 'inside', 'You glance up at the sky.')
        walk_to @settings.outdoor_room if weather =~ /inside/
        fput('perceive moons')

        # Look for a moon that will be up for the next few minutes
        unless moon = UserVars.moons.find { |moon_name, moon_data| UserVars.moons['visible'].include?(moon_name) && moon_data['timer'] >= 4 }.first
          echo "Couldn't find any moons to cast #{data['abbrev']} with"
          return
        end
      end
      data['cast'] = "cast #{moon}"
    end
    release_cyclics if data['cyclic']

    return unless prepare?(data['abbrev'], data['mana'], data['symbiosis'])

    find_charge_invoke_stow(@settings.cambrinth, @settings.stored_cambrinth, @settings.cambrinth_cap, @settings.dedicated_camb_use, data['cambrinth'])

    waitcastrt?

    snapshot = DRSkill.getxp(skill) if data['symbiosis']

    success = cast?(data['cast'], data['symbiosis'], data['before'], data['after'])

    return unless data['symbiosis']

    start = Time.now
    pause 0.5 until snapshot != DRSkill.getxp(skill) || Time.now - start > 10 || !success
    if !success
      UserVars.discerns[data['abbrev']]['more'] = [UserVars.discerns[data['abbrev']]['more'] - 1, 0].max
    elsif DRSkill.getxp(skill) - snapshot < @settings.symbiosis_learning_threshold
      UserVars.discerns[data['abbrev']]['more'] = UserVars.discerns[data['abbrev']]['more'] + 1
    end
  end
  
  def check_discern(data)
    UserVars.discerns = {} unless UserVars.discerns
    discern_data = UserVars.discerns[data['abbrev']] || {}
    if data['symbiosis']
      if discern_data.empty? || discern_data['min'].nil?
        /requires at minimum (\d+) mana streams/ =~ bput("discern #{data['abbrev']}", 'requires at minimum \d+ mana streams')
        discern_data['mana'] = Regexp.last_match(1).to_i
        discern_data['cambrinth'] = nil
        discern_data['min'] = Regexp.last_match(1).to_i
        discern_data['more'] = 0
      end
      calculate_mana(discern_data['min'], discern_data['more'], discern_data, false)
    elsif discern_data.empty? || discern_data['time_stamp'].nil? || Time.now - discern_data['time_stamp'] > 24 * 60 * 60 || !discern_data['more'].nil?
      discern_data['time_stamp'] = Time.now
      case discern = bput("discern #{data['abbrev']}", 'The spell requires at minimum \d+ mana streams and you think you can reinforce it with \d+ more', 'You don\'t think you are able to cast this spell', 'You have no idea how to cast that spell')
      when /you don't think you are able/i, 'You have no idea how to cast that spell'
        discern_data['mana'] = 1
        discern_data['cambrinth'] = nil
      else
        discern =~ /minimum (\d+) mana streams and you think you can reinforce it with (\d+) more/i
        calculate_mana(Regexp.last_match(1).to_i, Regexp.last_match(2).to_i, discern_data, data['cyclic'])
      end
    end
    pause 1
    waitrt?
    UserVars.discerns[data['abbrev']] = discern_data
    data['mana'] = discern_data['mana']
    data['cambrinth'] = discern_data['cambrinth']
  end
  
  def calculate_mana(min, more, discern_data, cyclic)
    total = min + more
    total = (total * @settings.prep_scaling_factor).floor
    discern_data['mana'] = [(total / 4.0).ceil, min].max
    remaining = total - discern_data['mana']
    if remaining > @settings.cambrinth_cap
      discern_data['mana'] = discern_data['mana'] + (remaining - @settings.cambrinth_cap)
      remaining = total - discern_data['mana']
    end
    if cyclic
      discern_data['cambrinth'] = nil
      discern_data['mana'] = discern_data['mana'] + remaining
    elsif remaining > 0
      discern_data['cambrinth'] = []
      step_size = (remaining / 3.0).ceil
      while remaining > 0
        discern_data['cambrinth'] << [remaining, step_size].min
        remaining -= step_size
      end
    else
      discern_data['cambrinth'] = nil
    end
  end
end

Magic.new