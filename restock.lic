=begin
  Documentation: https://elanthipedia.play.net/Lich_script_repository#restock
=end

custom_require.call(%w[common common-items common-money])

$NUM_MAP = {
    'zero'=> 0,
    'one' => 1,
    'two'=> 2,
    'three'=> 3,
    'four'=> 4,
    'five'=> 5,
    'six'=> 6,
    'seven'=> 7,
    'eight'=> 8,
    'nine'=> 9,
    'ten'=> 10,
    'eleven'=> 11,
    'twelve'=> 12,
    'thirteen'=> 13,
    'fourteen'=> 14,
    'fifteen'=> 15,
    'sixteen'=> 16,
    'seventeen'=> 17,
    'eighteen'=> 18,
    'nineteen'=> 19,
    'twenty'=> 20,
    'thirty'=> 30,
    'forty'=> 40,
    'fifty'=> 50,
    'sixty'=> 60,
    'seventy'=> 70,
    'eighty'=> 80,
    'ninety'=> 90
}

class Restock
  include DRC

  def initialize
    setup

    items = parse_restockable_items
    items_to_restock = Array.new
    coin_needed = 0

    items.each do |item|
      if item['stackable']
        remaining = count_stackable_item(item['name'])
      else
        remaining = count_nonstackable_item(item['name'])
      end
 
      if remaining < item['quantity']
        num_needed = item['quantity'] - remaining
        buy_num = (num_needed / item['size'].to_f).ceil
        coin_needed += buy_num * item['price']
        item['buy_num'] = buy_num
        items_to_restock.push(item)
      end
    end  

    DRCM.ensure_copper_on_hand(coin_needed, @hometown) if coin_needed > 0

    items_to_restock.each do |item|
      item['buy_num'].times do
        DRCI.buy_item(item['room'],item['name'])
        DRCI.stow_hands
      end 
    end 

  end

  def setup
    @settings = get_settings
    @hometown = @settings.hometown
    @settings.storage_containers.each { |container| fput("open my #{container}") }
  end

  def parse_restockable_items
    item_list = @settings.restock
    hometown_data = get_data('consumables')[@hometown]
    items = Array.new

    item_list.each do |key,value|
      if hometown_data.key?(key)
        ht_data = hometown_data[key]
        data = ht_data.each{|k, v| ht_data[k] = value[k] if value.key?(k)}
        items.push(data)
      elsif valid_item_data?(value) 
        items.push(value)
      else
        echo "No hometown of explicit data for '#{key}'"
      end
    end 
    
    return items
  end

  def count_stackable_item(item)
    count_msg = bput("count my #{item}", "I could not find what you were referring to.", "tell you much of anything.", 'and see there \w+ .+ left.')
    case count_msg
    when 'I could not find what you were referring to.'
      count = 0
    when "tell you much of anything."
      echo "#{item} is marked as stackable but is not!"
      count = count_nonstackable_item(item) 
    else
      count_txt = count_msg.match(/and see there \w+ (.+) left./).captures.first.gsub('-',' ')
      count = text2num(count_txt) 
    end
    waitrt?
    return count
  end

  def count_nonstackable_item(item)
    /inside your (.*).|I could not find/ =~ bput("tap my #{item}", 'inside your (.*).', 'I could not find')
    tap_result = Regexp.last_match(1)
    if tap_result.nil?
      return 0
    else
      container = tap_result
      contents = DRC.bput("rummage /C #{item.split.last} IN MY #{container}", '^You rummage .*')
      return contents.scan(/#{item}/).size    
    end
  end

  def valid_item_data?(item_data)
    return false unless item_data.key?('name')
    return false unless item_data.key?('size')
    return false unless item_data.key?('room')
    return false unless item_data.key?('price')
    return false unless item_data.key?('stackable')
    return false unless item_data.key?('quantity')
    return true
  end

  def text2num(text_num)

    split_words = text_num.split(" ")
    g = 0

    split_words.each do |word|
      x = $NUM_MAP.fetch(word,nil)
      if x.nil?
        echo "Unknown number"
        return nil
      else
        if word.eql? "hundred" and g !=0
          g *= 100
        else
          g+= x
        end
      end

    end

    return g

  end


end

Restock.new
