=begin
  Documentation: TBD
=end

custom_require.call(%w(common common-items drinfomon))

# Define Scroll Info class
class ScrollInfo
  def initialize(container, index, container_index, ordinal, spell, type)
    # Instance variables
    @container = container
    @index = index
	@container_index = container_index
    @ordinal = ordinal
    @spell = spell
    @type = type
  end

  def container
    return @container
  end

  def spell
    return @spell
  end

  def ordinal
    return @ordinal
  end
  
  def index
	return @index
  end
  
  # represents the local index of the
  # scroll within the container
  def container_index
	return @container_index
  end

  def get_type
    return @type
  end

  def set_container(container)
    @container = container
  end
  
  def set_container_index(index)
	@container_index = index
  end
  
  def set_ordinal(ordinal)
	@ordinal = ordinal
  end
end

class ScrollSearch
  include DRC
  include DRCI

  def initialize

    # Variables
    @scroll_count = 0
	@global_scroll_index = UserVars.scroll_counter.nil? ? 0 : UserVars.scroll_counter
    @owned_scrolls = UserVars.owned_scrolls.empty? ? {} : UserVars.owned_scrolls
    
	# RESET ALL
	# UserVars.owned_scrolls = { }
	# @owned_scrolls = { }
	# UserVars.scroll_counter = 0

    $settings = get_settings()
    $debug_mode = $settings.debug_mode

    echo("Settings debug mode is: #{$debug_mode}") if $debug_mode
    if $settings.nil? || $settings.empty?
      echo("Settings was nil!") if $debug_mode
    end

    arg_definitions = 
    [
      [
		{ name: 'search', regex: /^sea.*/i, description: 'Searches given container and labels any unlabeled scrolls. ' },
        { name: 'container', regex: /\w+/i, description: 'The container to search. ' }
      ],
      [
      	{ name: 'list', regex: /^lis.*/i, optional: false, description: 'Lists all of the scrolls that have been categorized after a SEARCH. ' },
      ]
    ]

    args = parse_args(arg_definitions)

	unless args.search || args.list
		display_args(arg_definitions)
		return
	end

    pause

    if args.search
      if args.container.nil?
        echo_message("SPECIFY THE CONTAINER TO SEARCH!")
        return
      else
        search_container(args.container)
      end
	elsif args.list
      if @owned_scrolls.length <= 0
        echo_message("NO SCROLLS HAVE BEEN ADDED! SEARCH YOUR CONTAINERS FIRST!")
        return
      end

      echo("Total scroll count is: #{@owned_scrolls.length}") if $debug_mode
      display_scrolls()
    else
      echo_message("INVALID ACTION")
    end
  end

  def search_container(container)
    # return if invalid container

	unless exists?(container)
      echo("*** INVALID CONTAINER. ***")
      return
    end

    # Get long name of container
    $container_full = full_name(container)
    $container = get_noun($container_full)

    # iterate over all scroll types
    scroll_types = $settings.scroll_nouns

    if scroll_types.empty? || scroll_types.nil?
      echo_message("NO SCROLL TYPTES SET! SETUP YOUR YAML TO INCLUDE VALID \"scroll_types\".")
      return
	end

	echo("Scroll type count is: #{scroll_types.length}.") if $debug_mode

	# Clear current scroll listing from owned scrolls if
	# user is searching an existing container
	if @owned_scrolls[$container_full]
	  echo("Clearing scroll array for this container, since it was previously searched --- #{$container_full}!") if $debug_mode
	  @owned_scrolls[$container_full] = []
	end
	
	# reset scroll count
	@scroll_count = 0
	
    scroll_types.each do |scroll|
      echo "Searching for scrolls of type #{scroll}." if $debug_mode

      scroll_list = get_scrolls(scroll)
      next if scroll_list.empty?

      look_scrolls(scroll_list)
    end

    # Save scrolls to user variables.
	if UserVars.owned_scrolls.nil? && @owned_scrolls.nil?
	  echo("Creating an empty hash for vars!") if $debug_mode
	  UserVars.owned_scrolls = {}
	  return
	end
	
	existing_hash = UserVars.owned_scrolls ? UserVars.owned_scrolls.clone : @owned_scrolls.clone
	new_hash = @owned_scrolls
	existing_hash.merge!(new_hash) 

    UserVars.owned_scrolls = new_hash
	UserVars.scroll_counter = @global_scroll_index
	
    echo ("Total scrolls added: #{@owned_scrolls.length}!") if $debug_mode

	echo_message("SEARCH COMPLETED")
  end

  def display_scrolls()
    current_scrolls = UserVars.owned_scrolls

    if current_scrolls.length <= 0 || current_scrolls.nil?
      echo_message("NO SCROLLS TO DISPLAY -- SEARCH FIRST!")
      return
    end

	# Formatted Scroll listing
    echo("|#{' Scroll List '.center(73,'=')}|")
    echo("|#{'#'.center(5)}|#{'Scroll Name'.center(20)}|#{'Container'.center(30)}|#{'Type'.center(15)}|")
    echo("|#{''.center(73,'=')}|")

    # Iterate over scrolls to display
    current_scrolls.each do |container, scroll_array|
	  scroll_array.each_with_index do |scroll_info, index|
	  	echo_scroll_list_line(scroll_info.index, scroll_info.spell, scroll_info.container, scroll_info.get_type)
	  end
    end

    echo("|#{''.center(73,' ')}|")
    echo("|#{'(;send <get #> or ;send <transfer # to <container>>)'.center(73,' ')}|")
    echo("|#{''.center(73,'=')}|")

    line = get until line.strip =~ /^get\s+(\d+)$|^tran.+\s+(\d+)\s+to\s+(\w+)$/i

    case line
    when /^get\s+(\d+)$/i
      scroll_index = Regexp.last_match(1)
      echo("Scroll index is #{scroll_index}.") if $debug_mode

      grab_scroll(scroll_index)
    when /^tran.+\s+(\d+)\s+to\s+(\w+)$/i
      scroll_index = Regexp.last_match(1)
      transfer_container = Regexp.last_match(2)

      echo("Index is #{scroll_index}. Transfer is: #{transfer_container}") if $debug_mode

      transfer_scroll(scroll_index, transfer_container)
    end
  end

  # Private methods
  private

  def get_scrolls(scroll)
    scroll_noun = scroll #get_noun(scroll)
    parameter = "C #{scroll_noun}"
    scrolls = rummage(parameter, $container)
    return scrolls
  end

  def look_scrolls(all_scrolls)

    all_scrolls.each_with_index do |scroll, index|
      ordinal = $ORDINALS[index]

      case scroll_look = bput("look #{ordinal} #{scroll} in my #{$container}", 'It is labeled "\w*\s*\w*."', '.* of the \w*\s*\w* spell.', 'three-dimensional shapes cover much of the scroll', 'You see nothing unusual.', 'I could not find what you were referring to')
      when 'three-dimensional shapes cover much of the scroll' then read_scroll(scroll)
      when /It is labeled "(\w*\s*\w*)."/i
        spell_name = Regexp.last_match(1).empty? ? "Undefined" : Regexp.last_match(1)
        echo ("Spell is #{spell_name}") if $debug_mode

        # If we cannot match, move on to the
        # next scroll
        if spell_name =~ "Undefined"
          next
        end

        new_scroll = ScrollInfo.new("#{$container_full}", @global_scroll_index, index, "#{ordinal}", "#{spell_name}", "#{scroll}")
		
		# Get list of scrolls for this container
		scroll_array = []
		
		if @owned_scrolls.key? ($container_full)
		  scroll_array = @owned_scrolls[$container_full]
			
		  scroll_array.push(new_scroll)
		  echo("1. Scroll size is #{scroll_array.length}") if $debug_mode
		else
		  scroll_array.push(new_scroll)
		  echo("2. Scroll size is #{scroll_array.length}") if $debug_mode
		end
		
		echo("Adding scroll array of size #{scroll_array.length} to hash.") if $debug_mode
		@owned_scrolls[$container_full] = scroll_array
      end

      @scroll_count += 1
	  @global_scroll_index += 1
    end
  end

  def read_scroll(scroll)
    bput("get $ORDINALS[#{@scroll_count}] #{scroll} from my #{$container}", 'You get')

    #case bput("read #{scroll}", 'The writing is too small', )
    #when 'The writing is too small' then hold_scroll(scroll)
  end

  def transfer_scroll(index, container)
    # Retrieve scroll info 
    scroll_info = get_scroll_info(index)

    echo("Got scroll info with spell: #{scroll_info.spell}") if $debug_mode

    # Get previous values
    cur_scroll_container = get_noun(scroll_info.container)
    cur_scroll_ordinal = scroll_info.ordinal
    cur_scroll_type = scroll_info.get_type

    # Make sure containers are opened
    bput("open my #{container}", 'That is already open', 'You open', 'You can\'t open that')
    bput("open my #{cur_scroll_container}", 'That is already open', 'You open')

    bput("get #{cur_scroll_ordinal} #{cur_scroll_type} from my #{cur_scroll_container}", 'You get')

	# Reorder the origin container
	reorder_container(scroll_info.container, scroll_info, true)
	resave_container(scroll_info.container, scroll_info, true)
	
	container_noun = container
	container = full_name(container)
	
	# Reorder destination container
	reorder_container(container, scroll_info, false)
	
	bput("put my #{cur_scroll_type} in my #{container_noun}", 'You put')
	
	# Transferred scrolls will always have a "first" ordinal
	scroll_info.set_ordinal($ORDINALS[0])
	scroll_info.set_container_index(0)
	
    # Edit scroll information
    scroll_info.set_container(container)
	
	# Resave scroll info
	resave_container(container, scroll_info, false)

    echo_message("SCROLL WAS TRANSFERRED!")
  end
  
  def reorder_container(container, scroll_info, wasRemoved)
    parameter = "C #{scroll_info.get_type}"
	scrolls = rummage(parameter, get_noun(container))
	
	echo("Scroll count of those matching the type (#{scroll_info.get_type}) is: #{scrolls.length}.") if $debug_mode
	
	scrolls_in_container = @owned_scrolls[container]
	scrolls_in_container.each do |scroll_information|
	
		if scroll_information.get_type != scroll_info.get_type
			next
		end
		
		if scroll_information.index == scroll_info.index
			next
		end
		
		if wasRemoved
			if scroll_information.container_index > scroll_info.container_index && scroll_information.container_index > 0
				new_index = scroll_information.container_index - 1
				new_ordinal = $ORDINALS[new_index]
			else
				new_index = scroll_information.container_index
				new_ordinal = $ORDINALS[new_index]
			end
		else
			new_index = scroll_information.container_index + 1
			new_ordinal = $ORDINALS[new_index]
		end
		
		echo("New ordinal and index for scroll (#{scroll_information.spell}) is: #{new_index} - #{new_ordinal}.") if $debug_mode
		
		scroll_information.set_ordinal(new_ordinal)
		scroll_information.set_container_index(new_index)
	end
  end

  def resave_container(container, scroll_info, remove)
  
	# if wasRemoved is true, we remove the scroll from
	# the container. If not, we simply add it to the container specified.
	
	if remove
		scrolls_in_container = @owned_scrolls[scroll_info.container]
		removed = scrolls_in_container.delete(scroll_info)
		if removed
			echo("Deleting scroll #{removed.spell} from container #{scroll_info.container}") if $debug_mode
			# Re-save owned scrolls listing
			@owned_scrolls[scroll_info.container] = scrolls_in_container
			
			# Re-save user variables
			UserVars.owned_scrolls = @owned_scrolls
		else
			echo_error("COULD NOT TRANSFER SCROLL TO NEW CONTAINER")
			exit
		end
	else
		echo ("Attempting to add scroll #{scroll_info.spell} to container #{container}.") if $debug_mode
		
		my_scroll_list = []

		if @owned_scrolls.key? (container)
			my_scroll_list = @owned_scrolls[container]
		end

		my_scroll_list.push(scroll_info)
		if my_scroll_list.length > 0
			echo("Adding scroll #{scroll_info.spell} to container #{container}. Length of array is #{my_scroll_list.length}") if $debug_mode
			# Re-save owned scrolls listing
			@owned_scrolls[container] = my_scroll_list
			
			# Re-save user variables
			UserVars.owned_scrolls = @owned_scrolls
			
			# List scrolls
			my_scroll_list.each do |scroll_array|
				echo("Scrolls in container is #{scroll_array.spell}") if $debug_mode
			end
			
			# List everything
			@owned_scrolls.each do |container, scroll_array|
				scroll_array.each do |scroll_information|
					echo("Container #{container} | #{scroll_information.spell}") if $debug_mode
				end
			end
		else
			echo_message("COULD NOT ADD SCROLL TO CONTAINER")
			exit
		end
	end
	
  end
  
  def grab_scroll(index)
	echo ("Index in grab scroll of scroll is: #{index}.") if $debug_mode
	
    # Retrieve scroll info 
    scroll_info = get_scroll_info(index)
    echo("Got scroll info with spell: #{scroll_info.spell}") if $debug_mode

    # Get previous values
    cur_scroll_container = get_noun(scroll_info.container)
    cur_scroll_ordinal = scroll_info.ordinal
    cur_scroll_type = scroll_info.get_type

    bput("open my #{cur_scroll_container}", 'That is already open', 'You open')
	bput("get #{cur_scroll_ordinal} #{cur_scroll_type} from my #{cur_scroll_container}", 'You get')
	
	# Reorder container
	reorder_container(scroll_info.container, scroll_info, true)
	
	# Remove this scroll from our hash map
	scrolls_in_container = @owned_scrolls[scroll_info.container]
	
	echo("Scrolls in container count is: #{scrolls_in_container.length}") if $debug_mode
	scrolls_in_container.each do |scroll_information|
		echo ("Index of current scroll in container is: #{scroll_information.index}. Index is: #{index}") if $debug_mode
		if scroll_information.index != index.to_i
			next
		else
			echo ("Found scroll we want to remove from listing... #{scroll_information.spell}") if $debug_mode
			scrolls_in_container.delete(scroll_information)
		end
		
	# Re-save owned scrolls listing
	@owned_scrolls[scroll_info.container] = scrolls_in_container
	
	# Re-save user variables
	UserVars.owned_scrolls = @owned_scrolls
	
	end

    echo_message("SCROLL WAS GRABBED!")
  end
  
  def full_name(noun)
	noun_name = bput("tap #{noun}", '^You tap ((\w+\s*\W*)+) that\s*.*')
	noun_name =~ /^You tap ((\w+\s*\W*)+) that\s*.*/i

	name_full = Regexp.last_match(1).empty? ? "Undefined" : Regexp.last_match(1)
	
	return name_full
  end

  def get_scroll_info(index)
	# Retrieve scroll info 
	current_scrolls = UserVars.owned_scrolls
	
	the_scroll = nil
	
	current_scrolls.each do |container, scroll_array|
	  scroll_array.each do |scroll_info|
		echo ("Iterating... index is: #{scroll_info.index}") if $debug_mode
			
		if scroll_info.index == index.to_i
		  echo ("Found scroll info : #{scroll_info.spell}") if $debug_mode
		  the_scroll = scroll_info
	    end
	  end
	end
	
	echo("The scroll is: #{the_scroll.spell}") if $debug_mode
	
	unless the_scroll
	  echo_message("INVALID SCROLL NUMBER")
	  exit
	end
	
	return the_scroll
  end

  def echo_scroll_list_line(index, name, container, type)
	echo("|#{index.to_s.center(5)}|#{name.center(20)}|#{container.center(30)}|#{type.center(15)}|")
  end
	
  def format_bar(padding, value)
	sprintf("%#{padding}s", value.to_s)
  end

  def echo_message(msg)
	echo("*** #{msg} ***")
  end
end

# Call this last to avoid the need for forward declarations
ScrollSearch.new