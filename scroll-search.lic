=begin
  Documentation: TBD
=end

custom_require.call(%w(common common-items drinfomon))

# Define Scroll Info class
class ScrollInfo
  def initialize(container, index, container_index, ordinal, spell, type)
	# Instance variables
	@container = container
	@index = index
	@container_index = container_index
	@ordinal = ordinal
	@spell = spell
	@type = type
  end

  attr_accessor :container
  attr_accessor :spell
  attr_accessor :ordinal

  # represents the local index of the
  # scroll within the container
  attr_accessor :container_index

  attr_reader :index
  attr_reader :type

end

class ScrollSearch
  include DRC
  include DRCI

  def initialize

	# Variables
	@scroll_count = 0
	@global_scroll_index = UserVars.scroll_counter || 0
	@owned_scrolls = UserVars.owned_scrolls.empty? ? {} : UserVars.owned_scrolls
    
	# RESET ALL
	# UserVars.owned_scrolls = { }
	# @owned_scrolls = { }
	# UserVars.scroll_counter = 0

	@settings = get_data("items")
	@debug_mode_ssearch = @settings.debug_mode

	echo("Settings debug mode is: #{@debug_mode_ssearch}") if @debug_mode_ssearch
	if @settings.nil? || @settings.empty?
	  echo("Settings was nil!") if @debug_mode_ssearch
	end

	arg_definitions = 
	[
	  [
		{ name: 'search', regex: /^sea.*/i, description: 'Searches given container and labels any unlabeled scrolls. ' },
		{ name: 'container', regex: /\w+/i, description: 'The container to search. ' }
	  ],
	  [
		{ name: 'list', regex: /^lis.*/i, optional: false, description: 'Lists all of the scrolls that have been categorized after a SEARCH. ' },
	  ]
	]

	args = parse_args(arg_definitions)

	pause

	if args.search
	  if args.container.nil?
		echo_message("SPECIFY THE CONTAINER TO SEARCH!")
		return
	  end

	  search_container(args.container)
	elsif args.list
	  if @owned_scrolls.length <= 0
		echo_message("NO SCROLLS HAVE BEEN ADDED! SEARCH YOUR CONTAINERS FIRST!")
	    return
	  end

	  echo("Total scroll count is: #{@owned_scrolls.length}") if @debug_mode_ssearch
	  display_scrolls()
	end
  end

  def search_container(container)
	# return if invalid container

	unless exists?(container)
	  echo_message("INVALID CONTAINER")
	  return
	end

	# Empty your hands
	stow_hands

	# Get long name of container
	$container_full = full_name(container)
	if $container_full =~ /Undefined/i
	  echo("Was unable to retrieve the full name of container: #{container}.") if @debug_mode_ssearch
	  $container_full = container
	end

	$container = get_noun($container_full)

	# iterate over all scroll types
	scroll_types = @settings.scroll_nouns

	if scroll_types.empty? || scroll_types.nil?
	  echo_message("NO SCROLL NOUNS SET! SETUP YOUR YAML TO INCLUDE VALID \"scroll_nouns\".")
	  return
	end

	echo("Scroll type count is: #{scroll_types.length}.") if @debug_mode_ssearch

	# Clear current scroll listing from owned scrolls if
	# user is searching an existing container
	if @owned_scrolls[$container_full]
	  echo("Clearing scroll array for this container, since it was previously searched --- #{$container_full}!") if @debug_mode_ssearch
	  @owned_scrolls[$container_full] = []
	end
	
	# reset scroll count
	@scroll_count = 0
	
	scroll_types.each do |scroll|
	  echo "Searching for scrolls of type #{scroll}." if @debug_mode_ssearch

	  scroll_list = get_scrolls(scroll)
	  next if scroll_list.empty?

	  look_scrolls(scroll_list)
	end

	# Save scrolls to user variables.
	if UserVars.owned_scrolls.nil? && @owned_scrolls.nil?
	  echo("Creating an empty hash for vars!") if @debug_mode_ssearch
	  UserVars.owned_scrolls = {}
	  return
	end
	
	UserVars.owned_scrolls = @owned_scrolls
	UserVars.scroll_counter = @global_scroll_index
	
	echo ("Total scrolls added: #{@owned_scrolls.length}!") if @debug_mode_ssearch

	# Empty your hands
	stow_hands

	echo_message("SEARCH COMPLETED")
  end

  def display_scrolls()
	current_scrolls = UserVars.owned_scrolls

	if current_scrolls.length <= 0 || current_scrolls.nil?
	  echo_message("NO SCROLLS TO DISPLAY -- SEARCH FIRST!")
	  return
	end

	# Formatted Scroll listing
	echo("|#{' Scroll List '.center(73,'=')}|")
	echo("|#{'#'.center(5)}|#{'Scroll Name'.center(20)}|#{'Container'.center(30)}|#{'Type'.center(15)}|")
	echo("|#{''.center(73,'=')}|")

	# Iterate over scrolls to display
	current_scrolls.each do |container, scroll_array|
	  scroll_array.each_with_index do |scroll_info, index|
		echo_scroll_list_line(scroll_info.index, scroll_info.spell, scroll_info.container, scroll_info.get_type)
	  end
	end

	echo("|#{''.center(73,' ')}|")
	echo("|#{'(;send <get #> or ;send <transfer # to <container>>)'.center(73,' ')}|")
	echo("|#{''.center(73,'=')}|")

	line = get until line.strip =~ /^get\s+(\d+)$|^tran.+\s+(\d+)\s+to\s+(\w+)$/i

	case line
	when /^get\s+(\d+)$/i
	  scroll_index = Regexp.last_match(1)
	  echo("Scroll index is #{scroll_index}.") if @debug_mode_ssearch

	  grab_scroll(scroll_index)
	when /^tran.+\s+(\d+)\s+to\s+(\w+)$/i
	  scroll_index = Regexp.last_match(1)
	  transfer_container = Regexp.last_match(2)

	  echo("Index is #{scroll_index}. Transfer is: #{transfer_container}") if @debug_mode_ssearch

	  transfer_scroll(scroll_index, transfer_container)
	end
  end

  # Private methods
  private

  def get_scrolls(scroll)
	scroll_noun = scroll
	parameter = "C #{scroll_noun}"
	scrolls = rummage(parameter, $container)
	return scrolls
  end

  def look_scrolls(all_scrolls)

	all_scrolls.each_with_index do |scroll, index|
	  # TODO: Fix so we support more than DR's hard-limit of 12
	  if index > 12 then next else end

	  ordinal = $ORDINALS[index]

	  case scroll_look = bput("look #{ordinal} #{scroll} in my #{$container}", 'It is labeled "\w*\s*\w*."', '.* of the \w*\s*\w* spell.', 'three-dimensional shapes cover much of the scroll', 'You see nothing unusual.', 'I could not find what you were referring to')
	  when 'three-dimensional shapes cover much of the scroll' then read_scroll(scroll)
	  when /It is labeled "(\w*\s*\w*)."/i
		spell_name = Regexp.last_match(1).empty? ? "Undefined" : Regexp.last_match(1)
		echo ("Spell is #{spell_name}") if @debug_mode_ssearch

		# If we cannot match, move on to the
		# next scroll
		if spell_name =~ /Undefined/i
		  next
		end

		new_scroll = ScrollInfo.new("#{$container_full}", @global_scroll_index, index, "#{ordinal}", "#{spell_name}", "#{scroll}")
		
		# Get list of scrolls for this container
		scroll_array = []
		
		if @owned_scrolls.key? ($container_full)
		  scroll_array = @owned_scrolls[$container_full]
			
		  scroll_array.push(new_scroll)
		  echo("1. Scroll size is #{scroll_array.length}") if @debug_mode_ssearch
		else
		  scroll_array.push(new_scroll)
		  echo("2. Scroll size is #{scroll_array.length}") if @debug_mode_ssearch
		end
		
		echo("Adding scroll array of size #{scroll_array.length} to hash.") if @debug_mode_ssearch
		@owned_scrolls[$container_full] = scroll_array
	  end

	  @scroll_count += 1
	  @global_scroll_index += 1
	end
  end

  def read_scroll(scroll)
	# TODO: Fix
	the_ordinal = $ORDINALS[@scroll_count]
	bput("get #{the_ordinal} #{scroll} from my #{$container}", 'You get')

	#case bput("read #{scroll}", 'The writing is too small', )
	#when 'The writing is too small' then hold_scroll(scroll)
  end

  def transfer_scroll(index, container)
	# Retrieve scroll info 
	scroll_info = get_scroll_info(index)

	echo("Got scroll info with spell: #{scroll_info.spell}") if @debug_mode_ssearch

	# Get previous values
	cur_scroll_container = get_noun(scroll_info.container)
	cur_scroll_ordinal = scroll_info.ordinal
	cur_scroll_type = scroll_info.get_type

    # Make sure containers are opened
    bput("open my #{container}", 'That is already open', 'You open', 'You can\'t open that')
    bput("open my #{cur_scroll_container}", 'That is already open', 'You open')

    bput("get #{cur_scroll_ordinal} #{cur_scroll_type} from my #{cur_scroll_container}", 'You get')

	# Reorder the origin container
	reorder_container(scroll_info.container, scroll_info, true)
	resave_container(scroll_info.container, scroll_info, true)
	
	container_noun = container
	container = full_name(container)

	# Just warn the user if we cannot get
	# the full name of the container for some reason.
	if container =~ /Undefined/i
	  echo("Was unable to retrieve the full name of this container...") if @debug_mode_ssearch
	end
	
	# Reorder destination container
	reorder_container(container, scroll_info, false)
	
	bput("put my #{cur_scroll_type} in my #{container_noun}", 'You put')
	
	# Transferred scrolls will always have a "first" ordinal
	scroll_info.set_ordinal($ORDINALS[0])
	scroll_info.set_container_index(0)
	
	# Edit scroll information
	scroll_info.set_container(container)
	
	# Resave scroll info
	resave_container(container, scroll_info, false)

	echo_message("SCROLL WAS TRANSFERRED!")
  end

  def reorder_container(container, scroll_info, wasRemoved)
	parameter = "C #{scroll_info.get_type}"
	scrolls = rummage(parameter, get_noun(container))
	
	echo("Scroll count of those matching the type (#{scroll_info.get_type}) is: #{scrolls.length}.") if @debug_mode_ssearch
	
	scrolls_in_container = @owned_scrolls[container]
	scrolls_in_container.each do |scroll_information|
	
	  if scroll_information.get_type != scroll_info.get_type
		next
	  end
		
	  if scroll_information.index == scroll_info.index
		next
	  end
		
	  if wasRemoved
		if scroll_information.container_index > scroll_info.container_index && scroll_information.container_index > 0
		  new_index = scroll_information.container_index - 1
		  new_ordinal = $ORDINALS[new_index]
		else
		  new_index = scroll_information.container_index
		  new_ordinal = $ORDINALS[new_index]
		end
	  else
		new_index = scroll_information.container_index + 1
		new_ordinal = $ORDINALS[new_index]
	  end
		
	  echo("New ordinal and index for scroll (#{scroll_information.spell}) is: #{new_index} - #{new_ordinal}.") if @debug_mode_ssearch
		
	  scroll_information.set_ordinal(new_ordinal)
	  scroll_information.set_container_index(new_index)
	end
  end

  def resave_container(container, scroll_info, remove)
  
	# if wasRemoved is true, we remove the scroll from
	# the container. If not, we simply add it to the container specified.
	
	if remove
	  scrolls_in_container = @owned_scrolls[scroll_info.container]
	  removed = scrolls_in_container.delete(scroll_info)
	  unless removed
	  	echo_message("COULD NOT TRANSFER SCROLL TO NEW CONTAINER")
		exit
	  else
		echo("Deleting scroll #{removed.spell} from container #{scroll_info.container}") if @debug_mode_ssearch
		# Re-save owned scrolls listing
		@owned_scrolls[scroll_info.container] = scrolls_in_container
			
		# Re-save user variables
		UserVars.owned_scrolls = @owned_scrolls
	  end
	else
	  echo ("Attempting to add scroll #{scroll_info.spell} to container #{container}.") if @debug_mode_ssearch
		
	  my_scroll_list = []

	  if @owned_scrolls.key? (container)
		my_scroll_list = @owned_scrolls[container]
	  end

	  my_scroll_list.push(scroll_info)
	  unless my_scroll_list.length > 0
	  	echo_message("COULD NOT ADD SCROLL TO CONTAINER")
		exit
	  else
		echo("Adding scroll #{scroll_info.spell} to container #{container}. Length of array is #{my_scroll_list.length}") if @debug_mode_ssearch
		# Re-save owned scrolls listing
		@owned_scrolls[container] = my_scroll_list
			
		# Re-save user variables
		UserVars.owned_scrolls = @owned_scrolls
			
		# List scrolls
		my_scroll_list.each do |scroll_array|
		  echo("Scrolls in container is #{scroll_array.spell}") if @debug_mode_ssearch
		end
			
		# List everything
		@owned_scrolls.each do |container, scroll_array|
		  scroll_array.each do |scroll_information|
			echo("Container #{container} | #{scroll_information.spell}") if @debug_mode_ssearch
		  end
		end
	  end
	end
  end
  
  def grab_scroll(index)
	echo ("Index in grab scroll of scroll is: #{index}.") if @debug_mode_ssearch
	
    # Retrieve scroll info 
	scroll_info = get_scroll_info(index)
	echo("Got scroll info with spell: #{scroll_info.spell}") if @debug_mode_ssearch

	# Get previous values
	cur_scroll_container = get_noun(scroll_info.container)
	cur_scroll_ordinal = scroll_info.ordinal
	cur_scroll_type = scroll_info.get_type

	bput("open my #{cur_scroll_container}", 'That is already open', 'You open')
	bput("get #{cur_scroll_ordinal} #{cur_scroll_type} from my #{cur_scroll_container}", 'You get')
	
	# Reorder container
	reorder_container(scroll_info.container, scroll_info, true)
	
	# Remove this scroll from our hash map
	scrolls_in_container = @owned_scrolls[scroll_info.container]
	
	echo("Scrolls in container count is: #{scrolls_in_container.length}") if @debug_mode_ssearch

	scrolls_in_container.select { |scroll_information|
	  scroll_information.index == index.to_i}.each do |scroll_info|
	  	echo ("Found scroll we want to remove from listing... #{scroll_info.spell}") if @debug_mode_ssearch
	  	scrolls_in_container.delete(scroll_info)
	end
		
	# Re-save owned scrolls listing
	@owned_scrolls[scroll_info.container] = scrolls_in_container
	
	# Re-save user variables
	UserVars.owned_scrolls = @owned_scrolls

	echo_message("SCROLL WAS GRABBED!")
  end
  
  def full_name(noun)
	noun_name = bput("tap #{noun}", '^You tap ((\w+\s*\W*)+) (that|inside)\s*.*')
	noun_name =~ /^You tap ((\w+\s*\W*)+) (that|inside)\s*.*/i

	if Regexp.last_match(3).include? ("inside")
	  bput("get #{noun}", 'You get')
	end
	
	name_full = Regexp.last_match(1).empty? ? "Undefined" : Regexp.last_match(1)
	
	return name_full
  end

  def get_scroll_info(index)
	# Retrieve scroll info 
	current_scrolls = UserVars.owned_scrolls
	
	the_scroll = nil
	
	current_scrolls.each do |container, scroll_array|
	  the_scroll = scroll_array.find { |scroll_info| scroll_info.index == index.to_i }

	  unless the_scroll.nil?
	    echo ("Found scroll info : #{the_scroll.spell}") if @debug_mode_ssearch
	    break
	  end
	end
	
	echo("The scroll is: #{the_scroll.spell}") #if @debug_mode_ssearch
	
	unless the_scroll
	  echo_message("INVALID SCROLL NUMBER")
	  exit
	end
	
	return the_scroll
  end

  def echo_scroll_list_line(index, name, container, type)
	echo("|#{index.to_s.center(5)}|#{name.center(20)}|#{container.center(30)}|#{type.center(15)}|")
  end
	
  def format_bar(padding, value)
	sprintf("%#{padding}s", value.to_s)
  end

  def echo_message(msg)
	echo("*** #{msg} ***")
  end
end

# Call this last to avoid the need for forward declarations
ScrollSearch.new
